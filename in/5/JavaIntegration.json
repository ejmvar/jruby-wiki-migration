{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JavaIntegration/revisions/5.json","name":"JavaIntegration","number":5,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JavaIntegration.json","person":"pfussell","description":"added title and link to home page, minor edits","text":"[[Home|&raquo; JRuby Project Wiki Home Page]]\n<h1>Embedding JRuby</h1>\n__TOC__\n\n==Using the JRuby Interpreter from Java==\n\n===Java 6 (using JSR 223: Scripting) ===\nJava integration with Java 6 will be using the standard scripting API (JSR223).  A JRuby scripting engine already exists and is located at [https://scripting.dev.java.net/]. \n#Download and unzip the collection of jars from the documents and files section of the site (jsr223-engines.tar.gz or jsr223-engines.zip). \n# Look in the uncompressed files for the <tt>jruby/build/jruby-engine.jar</tt> file.\n# Add this file to your classpath and then use the code below to access the engine.<br/> If you're using JRuby 1.1RC3 and 1.1.x on Java 6, use [https://scripting.dev.java.net/servlets/ProjectDocumentList?folderID=8848&expandFolder=8848&folderID=0 version 1.1.2 or later of the JRuby engine].\n\n<pre name=\"java\">\nimport javax.script.ScriptContext;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n{...}\nScriptEngineManager m = new ScriptEngineManager();\nScriptEngine rubyEngine = m.getEngineByName(\"jruby\");\nScriptContext context = rubyEngine.getContext();\n\ncontext.setAttribute(\"label\", new Integer(4), ScriptContext.ENGINE_SCOPE);\n\ntry{\n    rubyEngine.eval(\"puts 2 + $label\", context);\n} catch (ScriptException e) {\n    e.printStackTrace();\n}\n</pre>\n\n<tt>ScriptEngine.eval</tt> also takes a <tt>java.io.Reader</tt> object, which allows you to get load scripts from Files or other resource streams very simply, through the same interface.  The context parameter is optional.\n\nIf you want to use the scripting API on Java 5, use version 1.1.3 or later of the JRuby engine. Additionally, download <tt>sjp-1_0-fr-ri.zip</tt> from [http://www.jcp.org/en/jsr/detail?id=223], then unzip it and add <tt>script-api.jar</tt> to your classpath. \n\nJava 5 users might want to use <tt>com.sun.script.jruby.JRubyScriptEngineManager</tt> instead of <tt>javax.script.ScriptEngineManager</tt> to avoid version mismatch errors. However, if you are sure that you don't have any other script engines' archives compiled on JDK 1.6, you can use <tt>javax.script.ScriptEngingManager</tt> to get the engine's instance.\n\nIf you can't use Java 6, you can use the Apache Bean Scripting Framework.\n\nWhen running the compiled code, be sure to use a java invocation similar to the following:\n\n java -cp .:scripts:bsf.jar:jruby.jar:jruby-engine.jar -Djruby.home=/path/to/jruby/home  my.class.ScriptRunner\n\nThe <tt>-Djruby.home</tt> part is necessary so the system can find the ruby libraries.\n\nSee [http://wiki.jruby.org/wiki/Walkthroughs_and_Tutorials#JSR_223_scripting Walkthroughs and Tutorials: JSR 223 scripting] for more information.\n\n===Embedding with Bean Scripting Framework (BSF) ===\nThe [[Bean Scripting Framework]], when used with JRuby, will allow you to conveniently to pass your own Java objects to your JRuby script. You can then use these objects in JRuby, and changes will affect your Java program directly. To run a JRuby script using BSF, you must first copy the <tt>BSF.jar</tt> file into your <tt>JAVA_HOME/lib/ext/</tt> folder. Then, try the following:\n<pre name=\"java\">\nimport org.jruby.Ruby.*;\nimport org.jruby.*;\nimport org.jruby.javasupport.bsf.*;\nimport org.apache.bsf.BSFException;\nimport org.apache.bsf.BSFManager;\n{...}\nJLabel mylabel = new JLabel();\nBSFManager.registerScriptingEngine(\"ruby\", \n                                   \"org.jruby.javasupport.bsf.JRubyEngine\", \n                                   new String[] { \"rb\" });\n\nBSFManager manager = new BSFManager();\n\n/* Import an object using declareBean then you can access it in JRuby with $<name> */\n \nmanager.declareBean(\"label\", mylabel, JFrame.class);\nmanager.exec(\"ruby\", \"(java)\", 1, 1, \"$label.setText(\\\"This is a test.\\\")\");\n</pre>\n\n===Directly calling JRuby APIs===\nSee [[Direct JRuby Embedding]]. The BSF and <tt>javax.scripting</tt> APIs are strongly recommended, as they are most likely to always do the \"right thing\", which can change over time in the direct version.\n\n==Gotchas==\nIf you plan on calling gems from an embedded script, there are a couple of things you need to be aware of: \n\n* If you <tt>require</tt> <tt>'rubygems'</tt>, you need to make sure you set a few system properties: <tt>jruby.base</tt>, <tt>jruby.home</tt>, <tt>jruby.lib</tt>, <tt>jruby.shell</tt>, and <tt>jruby.script</tt>. You can look in <tt>bin/jruby</tt> (a shell script) or <tt>jruby.bat</tt> for examples of setting these properties from the command line. If you can't set them on the command line, you'll need to set them programmatically, or you'll receive a <tt>NullPointerException</tt> when <tt>RbConfigLibrary</tt> loads.\n\n* Make sure you get the load path set properly. Running <tt>jirb</tt> and calling <tt>$LOAD_PATH.inspect</tt> should give you a good idea of what paths need to be included. All those paths can be set in the same way you'd set a Java classpath. However, one reference to <tt>*lib/ruby/1.8*</tt> has to remain relative. This is because some files (<tt>*digest/sha2*</tt>, for example) are loaded from the <tt>jruby.jar</tt>. If you're running unit tests from Ant, you might have problems because Ant tends to expand path elements. Fortunately, it's easy enough to append <tt>lib/ruby/1.8</tt> to the load path before calling <tt>require</tt> <tt>'rubygems'</tt> in your scripts.\n\nHere's an example of a load path from Linux:\n<pre>\nirb(main):004:0> puts $LOAD_PATH\n/home/username/jruby/lib/ruby/site_ruby/1.8\n/home/username/jruby/lib/ruby/site_ruby\n/home/username/jruby/lib/ruby/1.8\n/home/username/jruby/lib/ruby/1.8/java\nlib/ruby/1.8\n.\n=> nil\n</pre>\n\nHere's an example of a load path for Windows:\n<pre>\nC:/common/jruby-0.9.2/lib/ruby/site_ruby/1.8\nC:/common/jruby-0.9.2/lib/ruby/site_ruby/1.8/java\nC:/common/jruby-0.9.2/lib/ruby/site_ruby\nC:/common/jruby-0.9.2/lib/ruby/1.8\nC:/common/jruby-0.9.2/lib/ruby/1.8/java\nlib/ruby/1.8\n</pre>\n\nThese settings are specific to my system. Make sure the paths are correct for your system.\n\nIf you declare a bean using BSF, make sure you undeclare it when you are done using it, ''even if you declare another bean using the same name''. BSF internally adds declared beans to a vector, and only removes them once they are undeclared.  Or, as an alternative, you can call <tt>registerBean</tt> and access the object from JRuby using the global $bsh reference.\n\n==See also==\n* [[Calling Java from JRuby]]\n* [[Accessing JRuby Object in Java]]\n\n==Related Articles==\n* [http://leandrosilva.com.br/2008/08/14/executar-jruby-a-partir-do-java Executar JRuby a partir do Java (pt_BR)] Article about integration of Java with JRuby, showing how to run JRuby code from Java.\n","created_at":"2009-06-20T00:24:25Z","content_type":"application/vnd.com.kenai.page.revision+json"}