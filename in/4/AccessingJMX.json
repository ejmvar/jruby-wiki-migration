{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/AccessingJMX/revisions/4.json","name":"AccessingJMX","number":4,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/AccessingJMX.json","person":"enebo","description":"Added comment about higher-level gems for accessing JMX","text":"This page shows an example of using the Java JMX packages directly from Ruby, but there are two gems which exist to make using JMX must less painful.  Consider using these packages before you break down and code this stuff by hand:\n\n* http://www.kenai.com/projects/jmxjr\n* http://github.com/jmesnil/jmx4r/\n\nThis code snippet shows how to access ActiveMQ's Dead Letter Queue (DLQ):\n\n require 'java'\n \n import java.rmi.MarshalledObject\n import java.rmi.registry.LocateRegistry\n import javax.management.ObjectName\n \n # Connect to the JNDI lookup server\n registry = LocateRegistry.get_registry(\"localhost\", 1099) \n \n # List available RMI objects\n names = registry.list\n puts 'Available RMI objects:'\n p names.to_a\n puts\n \n # Fetch a remote proxy to the JMX RMI object\n remote = registry.lookup(\"jmxrmi\")\n puts \"Got remote JMX object: #{remote.inspect}\"\n con = remote.new_client nil\n puts \"Got connection: #{con.inspect}\"\n \n # List JMX domains\n domains = con.get_domains nil\n puts \"Found domains:\"\n p domains.to_a\n \n # List available MBeans\n mbeans = con.query_names nil, nil, nil\n puts 'Available MBeans:'\n mbean_names = mbeans.to_a.map{|n| n.to_s}.sort\n puts mbean_names.join(\"\\n\")\n puts\n puts\n \n \n # Find the dead letter queue in ActiveMQ \n queue = mbean_names.find{|n| n =~ /org.apache.activemq.*Type=Queue.*Destination=ActiveMQ.DLQ/}\n if queue\n   puts 'Found ActiveMQ DLQ:'\n   p queue\n \n   puts \"Purging DLQ\"\n   name = ObjectName.new(queue)\n   res = con.invoke name, 'purge', MarshalledObject.new(nil), nil, nil\n   puts \"Result from purge: #{res.inspect}\"\n end\n","created_at":"2009-06-11T18:59:01Z","content_type":"application/vnd.com.kenai.page.revision+json"}