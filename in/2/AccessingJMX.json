{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/AccessingJMX/revisions/2.json","name":"AccessingJMX","number":2,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/AccessingJMX.json","person":"donv","description":"Added simple example","text":" require 'java'\n \n import java.rmi.MarshalledObject\n import java.rmi.registry.LocateRegistry\n import javax.management.ObjectName\n \n # Connect to the JNDI lookup server\n registry = LocateRegistry.get_registry(\"localhost\", 1099) \n \n # List available RMI objects\n names = registry.list\n puts 'Available RMI objects:'\n p names\n puts\n \n # Fetch a remote proxy to the JMX RMI object\n remote = registry.lookup(\"jmxrmi\")\n puts \"Got remote JMX object: #{remote.inspect}\"\n con = remote.new_client nil\n puts \"Got connection: #{con.inspect}\"\n \n # List JMX domains\n domains = con.get_domains nil\n puts \"Found domains:\"\n p domains.to_a\n \n # List available MBeans\n mbeans = con.query_names nil, nil, nil\n puts 'Available MBeans:'\n mbean_names = mbeans.to_a.map{|n| n.to_s}.sort\n puts mbean_names.join(\"\\n\")\n puts\n puts\n \n \n # Find the dead letter queue in ActiveMQ \n queue = mbean_names.find{|n| n =~ /org.apache.activemq.*Type=Queue.*Destination=ActiveMQ.DLQ/}\n if queue\n   puts 'Found ActiveMQ DLQ:'\n   p queue\n \n   puts \"Purging DLQ\"\n   name = ObjectName.new(queue)\n   res = con.invoke name, 'purge', MarshalledObject.new(nil), nil, nil\n   puts \"Result from purge: #{res.inspect}\"\n end\n","created_at":"2009-04-15T19:40:19Z","content_type":"application/vnd.com.kenai.page.revision+json"}