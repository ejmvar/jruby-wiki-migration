{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JRubyAndJavaCodeExamples/revisions/2.json","name":"JRubyAndJavaCodeExamples","number":2,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JRubyAndJavaCodeExamples.json","person":"pfussell","description":"Added  link to home page","text":"[[Home|&raquo; JRuby Project Wiki Home Page]]\n==JRuby and Java Code Examples==\nBelow are some code examples showing how to call ruby from within Java and Java from ruby.\n\n===Ruby:  <tt>call_java.rb</tt>===\n  require \"java\"\n  \n  include_class \"java.util.TreeSet\"\n  include_class \"com.example.CallMe\"\n  include_class \"com.example.ISpeaker\"\n  \n  puts \"Hello from ruby\"\n  set = TreeSet.new\n  set.add \"foo\"\n  set.add \"Bar\"\n  set.add \"baz\"\n  set.each { |v| puts \"value: #{v}\" }\n  \n  cm = CallMe.new\n  cm.hello\n  $globalCM.hello\n  \n  class CallJava\n    include ISpeaker\n    def initialize\n      super\n      @count = 0\n    end\n  \n    def say(msg)\n      puts \"Ruby saying #{msg}\"\n    end\n    \n    def addOne(from)\n  #    m.synchronize {\n        @count += 1\n        puts \"Now got #@count from #{from}\"\n  #    }\n    end\n  end\n\n===Java: <tt>ISpeaker.java</tt>===\n    package com.example;\n    \n    public interface ISpeaker {\n        public void say(String msg);\n        \n        public void addOne(String from);\n    }\n\n===Java: <tt>CallMe.java</tt>===\n\n    package com.example;\n    \n    public class CallMe {\n    \n        String mName;\n    \n        public CallMe() {\n            this(\"Default\");\n        }\n        \n        public CallMe(String name) {\n            mName = name;\n        }\n        \n        public void hello() {\n            System.out.println(\"Hello from \"+mName);\n        }\n        \n        public static void main(String []args) {\n            System.out.println(\"Called main\");\n        }\n    }\n\n===Java: <tt>CallRuby.java</tt>===\n    package com.example;\n    \n    import org.apache.bsf.BSFManager;\n    import org.apache.bsf.util.IOUtils;\n    import org.jruby.Ruby;\n    import org.jruby.javasupport.Java;\n    import org.jruby.javasupport.JavaEmbedUtils;\n    import org.jruby.javasupport.JavaUtil;\n    import org.jruby.runtime.Block;\n    import org.jruby.runtime.GlobalVariable;\n    import org.jruby.runtime.builtin.IRubyObject;\n    \n    import java.io.FileReader;\n    import java.io.IOException;\n    \n    /**\n     * Example of how to:\n     * 1. Use java objects in ruby\n     * 2. Subclass/implement java objects in ruby\n     * 3. Get ruby objects for use in java world\n     * 4. Proxy ruby objects for normal use as java objects (interfaces/class)\n     */\n    public class CallRuby {\n    \n        public static void main(String[] args) throws Exception {\n    \n            String dir = \"/dclark/workspace/jrubytest/ruby/\";\n    \n            double[] deltas = new double[3];\n            for (int i = 0; i < 3; i++) {\n                boolean useBSF = (i == 0);\n                long start = System.currentTimeMillis();\n    \n                if (useBSF) {\n                    //--- Initialise ruby\n                    BSFManager.registerScriptingEngine(\"ruby\", \"org.jruby.javasupport.bsf.JRubyEngine\", new String[]{\"rb\"});\n                    BSFManager manager = new BSFManager();\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    manager.declareBean(\"globalCM\", javaCallMe, javaCallMe.getClass());\n    \n                    //--- Load a ruby file\n                    manager.exec(\"ruby\", \"call_java.rb\", -1, -1, getFileContents(dir + \"call_java.rb\"));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    ISpeaker ruby = (ISpeaker) manager.eval(\"ruby\", \"call_java.rb\", -1, -1, expr);\n    \n                    testMultiThreadsCallingRubyObject(ruby);\n    \n                } else {\n    \n                    //--- Initialise ruby\n                    final Ruby runtime = Ruby.getDefaultInstance();\n    \n                    // Need the blank object so can get a nice runtime for the Java.staticMethods calls\n                    runtime.eval(runtime.parse(\"require \\\"java\\\"\\nclass BlankForJva\\nend\\n\", \"BlankForJva.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n                    final IRubyObject blankRuby = runtime.evalScript(\"BlankForJva.new\");\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    IRubyObject globValue = JavaUtil.convertJavaToRuby(runtime, javaCallMe);\n    \n                    // Wrap so that all methods are visible to ruby\n                    globValue = Java.java_to_ruby(blankRuby, globValue, Block.NULL_BLOCK);\n    \n                    GlobalVariable globVar = new GlobalVariable(runtime, \"$globalCM\", globValue);\n                    runtime.defineVariable(globVar);\n    \n                    //--- Load a ruby file\n                    runtime.eval(runtime.parse(getFileContents(dir + \"call_java.rb\"), \"call_java.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    final IRubyObject rawRuby = runtime.evalScript(expr);\n                    ISpeaker ruby;\n                    if (i == 1) {\n                        // Standard wrapper using Java Proxies\n                        ruby = (ISpeaker) JavaEmbedUtils.rubyToJava(runtime, rawRuby, ISpeaker.class);\n                    } else {\n                        // Or manually wrap ruby object so can be used as the interface (can optionally add synchronization as required on methods)\n                        ruby = new ISpeaker() {\n                            public void addOne(String from) {\n                                //                            synchronized (rawRuby) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"addOne\", JavaUtil.convertJavaToRuby(runtime, from));\n                                //                            }\n                            }\n    \n                            public void say(String msg) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"say\", JavaUtil.convertJavaToRuby(runtime, msg));\n                            }\n                        };\n                    }\n                    testMultiThreadsCallingRubyObject(ruby);\n                }\n                long end = System.currentTimeMillis();\n                deltas[i] = (end - start) / 1000.0;\n            }\n    \n            for (int i = 0; i < deltas.length; i++) {\n                System.out.println(\"Took \" + deltas[i] + \" on pass \" + i);\n            }\n        }\n    \n        private static String getFileContents(String filename) throws IOException {\n            FileReader in = new FileReader(filename);\n            return IOUtils.getStringFromReader(in);\n        }\n    \n        public static void testMultiThreadsCallingRubyObject(final ISpeaker ruby) throws InterruptedException {\n            Thread t1 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t1\");\n                    }\n                }\n            });\n            Thread t2 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t2\");\n                    }\n                }\n            });\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            ruby.addOne(\"end\");\n        }\n    }\n\n'''Note:''' If you have only simple interface requirements, you can use the second method of proxying the ruby object to include method level synchronization.\n\n'''Note:''' BSF calling does not preserve ruby stack traces (add an error to a script and run both ways using the code above).\n\n'''Note Also:''' The times you get from running this example are interesting (on my old Windows box using Java5):\n\n  Took 5.469 on pass 0  // This is the Standard BSF Wrapping\n  Took 1.75 on pass 1   // Using normal Java Proxies\n  Took 1.359 on pass 2  // Rolling your own redirector class to call Ruby\n","created_at":"2009-06-19T20:01:33Z","content_type":"application/vnd.com.kenai.page.revision+json"}