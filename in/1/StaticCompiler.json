{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/StaticCompiler/revisions/1.json","name":"StaticCompiler","number":1,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/StaticCompiler.json","person":"john_brock","description":"","text":"JRuby plans to support a static AOT compiler in the future, which will produce compiled Java classes that are actually implemented with Ruby code behind the scenes. This document discusses possible ways this compiler will function.\r\n\r\nGiven the following simple method:\r\n\r\n class MyClass\r\n   def foo(a, b); end\r\n end\r\n\r\nWe would expect the compiler to produce the following code:\r\n\r\n public class MyClass < IRubyObject {\r\n   public Object foo(Object a, Object b) {\r\n     Object result = callMethod(\"foo\", JavaUtil.convertJavaToRuby(a), JavaUtil.convertJavaToRuby(b));\r\n     return JavaUtil.convertRubyToJava(result);\r\n   }\r\n }\r\n\r\nThis is a simple place to start.\r\n\r\nQuestions, concerns:\r\n\r\n* Should underscore_case methods be compiled as camelCase? configurable?\r\n* We need to clearly specify what JavaUtil will do for all sorts of types\r\n\r\nPrimary requirements:\r\n\r\n* No modification of Ruby's grammar should be necessary; the code should be runnable in interpreted mode.\r\n* To the greatest extent possible, support all of Ruby's grammar being compiled into a static set of classes and methods.\r\n* Whether it must be a complete no-op or whether a small library of no-op functions would be needed in interpreted mode is up for debate.\r\n\r\n===Specifying types===\r\n\r\nA few possible syntaxes:\r\n\r\n {[:String, :Integer] => :int}\r\n def foo(a, b) ...\r\n\r\n [:String, :Integer] << :int\r\n def foo(a, b) ...\r\n\r\n java_method {\r\n   params String, int\r\n   return int\r\n }\r\n def foo(a, b) ...\r\n\r\n def foo(a, b) ...\r\n ...\r\n java_method :foo, [:String, :Integer] => :int\r\n\r\nThose with a method call would require some noop library to run correctly in interpreted mode.\r\n\r\n===Annotations===\r\n\r\nA few possible syntaxes\r\n\r\n @MyAnno = {:baz => \"blah\"}\r\n def foo() ...\r\n\r\n annotate { MyAnno(baz = \"blah\") }\r\n def foo() ...\r\n\r\n def foo() ...\r\n ...\r\n annotate :foo { MyAnno(bar = \"blah\") }\r\n\r\n===Attributes===\r\n\r\nIt's mostly a no-brainer that attributes should get compiled into Java get/set methods.\r\n\r\n class Blah\r\n   attr_accessor :foo\r\n end\r\n\r\nshould produce the following in the resulting Java class:\r\n\r\n public Object getFoo();\r\n public void setFoo(Object foo);\r\n","created_at":"2008-08-12T21:06:48Z","content_type":"application/vnd.com.kenai.page.revision+json"}