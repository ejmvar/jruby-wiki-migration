{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/RequireAndLoadBehavior/revisions/1.json","name":"RequireAndLoadBehavior","number":1,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/RequireAndLoadBehavior.json","person":"john_brock","description":"","text":"Documentation on LoadService behavior pre-patch and post-patch, in an attempt to simplify and speed loading. The two issues addressed are [http://jira.codehaus.org/browse/JRUBY-335 JRUBY-335] and [http://jira.codehaus.org/browse/JRUBY-288 JRUBY-288].\r\n\r\nThe altered version is simpler, more correct, and faster in some cases (rails, specifically). It's a pretty tangled web regardless.\r\n\r\n__TOC__\r\n\r\n=0.9.2 behavior=\r\n\r\nKernel.load calls \"findLibrary\" with an exact filename only.\r\nKernel.require calls \"findLibrary\" with the specified filename appended with four possible extensions in turn:\r\n#rb\r\n#ast.ser\r\n#rb.ast.ser\r\n#jar\r\nrequire also tries the filename as-is, which is incorrect behavior.\r\n\r\n==Default load path includes==\r\n#current dir (implicit, during searches)\r\n#the <JRuby lib> dir (as specified by jruby.lib system property)\r\n#<JRuby home>/lib/ruby/site_ruby/1.8 (note this and subsequent paths are using jruby.home property, not jruby.lib property)\r\n#<JRuby home>/lib/ruby/site_ruby/1.8/java\r\n#<JRuby home>/lib/ruby/site_ruby\r\n#<JRuby home>/lib/ruby/1.8\r\n#<JRuby home>/lib/ruby/site_ruby/1.8/java\r\n#<JRuby home>/lib/ruby\r\n#'.'\r\n\r\n==findLibrary==\r\n#checks builtin libraries first for supplied filename\r\n#calls \"findFile\" with given filename, returning null if result is null\r\n#if file (resource) is found:\r\n##if file ends with \".jar\", returns a JarredScript with specified resource\r\n##if file ends with \".rb.ast.ser\", returns a PreparsedScript with specified resource\r\n##otherwise returns ExternalScript with resource and supplied filename\r\n\r\n==findFile==\r\n#if file starts with \"jar:\" returns LoadServiceResource using supplied filename directly as a URL\r\n#if file is found in current dir and resulting current-dir + filename is absolute, returns LoadServiceResource with current-dir + filename as URL\r\n#retrieves a classloader from the JavaSupport object for this runtime (which ends up using the classloader in which that JavaSupport was loaded, usually System classloader)\r\n#replaces \\\\ with / in filename\r\n#if filename starts with /, attempts to load from classloader resources (this is incorrect; classloader resources *can not* start with a '/'.\r\n#Iterates over all entries in the load path:\r\n##If load path entry starts with \"jar:\" attempts to load from an associated JarFile, caching JarFile objects as they are encountered and instantiated.\r\n##Attempts to load file from the absolute path of (current dir + load path entry) (seems wrong to me, and creates two JRubyFile objects every time)\r\n##Attempts to load file from load path entry with '\\\\' substituted with '/' (also seems quite wrong, since most files' load paths will be absolute paths for ruby/1.8 and similar dirs, which would never work in a classloader)\r\n#attempts to load the filename directly from the classloader (again) regardless of whether it starts with / or not.\r\n#Failing all of the above, returns null, usually resulting in findLibrary returning nil. For require, this will then advance to the next extension\r\n\r\n=Problems with 0.9.2 behavior=\r\n\r\n*require should never attempt to load the supplied name without appending extensions. With a file 'foo' in the current dir, require 'foo' should still fail, only accepting foo with some extension.\r\n*For each extension, all possible locations are checked first, many involving classloader resources. This means that resources on the filesystem may take longer to lookup since they may come after many classloader hits.\r\n*We have no files with extension \".ast.ser\" that aren't \".rb.ast.ser\", and I know of no reason why we ever would.\r\n*Classloader resources are checked for all supplied filenames that start with '/', even though this is not valid for classloader resources.\r\n*Classloader resources are (possibly again) checked for each load path, even though most load paths will be absolute paths to ruby/1.8 and related dirs.\r\n*Classloader resources are checked a third time if nothing has been found using the same bare filename. If the file starts with '/' and nothing was found for the first classloader resource check above, this results in a repeat of the same search.\r\n*We do not have a site_ruby/1.8/java dir. I'm not sure we ever will need it.\r\n*We should not search \".\", since changing the current dir (Dir.chdir) should cause files in our initial PWD to no longer be implicitly locatable (and \".\" will always resolve to the JVM's startup PWD)\r\n\r\n=New behavior (provided by supplied patch in JRUBY-335)=\r\n\r\n*Kernel.load behavior is unchanged, other than incidental changes in classloader resource lookup as a result of calling findLibrary and findLibraryWithClassloaders (documented below)\r\n*Kernel.require behavior excludes as-is filenames from search\r\n*the ast.ser extension is eliminated\r\n*the site_ruby/1.8/java load path entry is removed\r\n*the '.' load path entry is removed\r\n\r\n==The \"smartLoad\" method used for searching all expected extensions is changed as follows==\r\n\r\n*it performs one search of all extensions against only filesystem-based locations\r\n*it performs a second search of all extensions using classloader resource lookups or using direct URL-based resources (i.e. jar: urls)\r\n\r\n==Both searches==\r\n\r\n*eliminate substituting '\\\\' for '/' in filenames (JRubyFile and Java's own logic should handle this ok, but this should be tested on Windows)\r\n\r\n==The filesystem-based search==\r\n\r\n#checks for the file in the current directory\r\n#checks for the file using each load path entry in turn\r\n\r\n==The classloader and URL-based search==\r\n\r\n#checks for jar: URLs and loads if found\r\n#retrieves Thread's context classloader (rather than always using the classloader JRuby was loaded in)\r\n#For each entry in the load path:\r\n##if entry is a jar: URL, uses that to load and cache JarFile objects that are then used to load the file if possible\r\n##if entry does not start with /, attempts to load from classloader resources\r\n#if filename does not start with /, attempts to load from classloader resources\r\n#if all else fails, returns null, usually resulting in the smartLoad search proceeding to the next extension\r\n\r\n=Justification for changes=\r\n\r\nThe changes\r\n\r\n*simplify the loading process\r\n*eliminate extraneous paths that can not or should not be searched\r\n*eliminate repetitive classloader resource searching\r\n*eliminate searching of classloaders or jar loading until all potential filesystem locations have been exhausted\r\n*appear to speed a simple \"jirb\" load by a very small amount\r\n*improves the load time of a rails script from 8.7 seconds to 7.7 seconds (time jruby script/console --help)\r\n*improves the load time of the same script with a very large classpath from 9 seconds to 7.8 seconds\r\n","created_at":"2008-08-12T20:49:16Z","content_type":"application/vnd.com.kenai.page.revision+json"}