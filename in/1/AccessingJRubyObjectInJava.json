{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/AccessingJRubyObjectInJava/revisions/1.json","name":"AccessingJRubyObjectInJava","number":1,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/AccessingJRubyObjectInJava.json","person":"john_brock","description":"","text":"Two Examples of accessing Ruby classes in Java use a script Engine.  The first example uses Java 5 and previous versions.  The second example uses Java 6 and the the scripting engine.\r\n\r\n'''Java 5 Example'''\r\nThis example shows your can access the JRuby Object in Java 5 , it is not as elegant as the solution in Java 6 but that discussion will follow later.  Specifically this example uses getDefualtInstance to instantiate a Ruby environment.\r\nWe then added java variables tot he script String and evaled that string.  The java variables were Yamled to  the specific file.  TO  do this correctly there are certain dependencies that must added to the build path.  the Jruby complete jar for Ruby stdlib.\r\n<code> \r\n  package jrubyfromJava; \r\n  import org.jruby.*; \r\n  public class JrubyTest { \r\n        \r\n                \r\n                public static void main(String[] ARGV){ \r\n                        \r\n                        System.out.println(\"starting\"); \r\n                        Ruby runtime = Ruby.getDefaultInstance(); \r\n                         System.out.println(\"ruby instantiated\"); \r\n                        String script = \"require 'java'\\n\"+ \r\n                                                        \"require 'yaml'\\n\"+ \r\n                                                        \"testObj = Object.new\\n\"+ \r\n                                                        \"puts 'running java'\\n\"+ \r\n                                                        //\"File.open('test.yml','w') { |out| YAML.dump(testInfoObj, out )}\\n\" + \r\n                                                        \"puts 'closed file'\\n\" + \r\n                                                        \" testObj  = File.open('test.yml', 'r'){|yf| YAML.load(yf)}\\n\" + \r\n                                                        \"puts testObj\"; \r\n                        \r\n                        runtime.evalScript(script); \r\n                        //script engine test.   \r\n                } \r\n</code> \r\n\r\n \r\n'''Java 6'''\r\n\r\nJava 6 handles the accessing of Java variables more handily. When the engine gets instantiated a context for each variable that you want to pass in and out of the eval string is set.  Now we can access the variable after it has been evaled by Jruby.  The changes are retained within the set Context.\r\n\r\n\r\n<code> \r\n package jrubyfromJava; \r\n import javax.script.ScriptContext; \r\n import javax.script.ScriptEngine; \r\n import javax.script.ScriptEngineManager; \r\n import javax.script.ScriptException; \r\n public class scriptEngineTest { \r\n        /** \r\n         * @param args \r\n         */ \r\n        public static void main(String[] args) { \r\n                ScriptEngineManager m = new ScriptEngineManager(); \r\n                ScriptEngine rubyEngine = m.getEngineByName(\"jruby\"); \r\n                //setting the Context for the label variable\r\n                rubyEngine.getContext().setAttribute(\"label\",new Float(1.0), ScriptContext.ENGINE_SCOPE); \r\n                \r\n                \r\n                        //ScriptContext context = null; \r\n                        try { \r\n                                rubyEngine.eval(\"require 'java'\\n\"+ \r\n                                                        \"require 'yaml'\\n\"+ \r\n                                                        \"testObj = Object.new\\n\"+ \r\n                                                        \"puts 'running java'\\n\"+ \r\n                                                        //\"File.open('test.yml','w') { |out| YAML.dump(testInfoObj, out )}\\n\" + \r\n                                                        \"puts 'closed file'\\n\" + \r\n                                                        \"f = File.open('test.yml', 'r'){|yf| YAML.load(yf)}\\n\" + \r\n                                                        \"puts testObj \r\n                                                \"$nv = f.name+f.version.to_s\"); \r\n                                \r\n                                Object nv = rubyEngine.getContext().getAttribute(\"nv\"); \r\n                                System.out.println(nv.toString()); \r\n                        } catch (ScriptException e) { \r\n                                // TODO Auto-generated catch block \r\n                                e.printStackTrace(); \r\n                        } \r\n        } \r\n } \r\n</code> \r\n\r\nThe Object.new is not the object code I used.  I had to change it because it was private.  if you change it to array it will work just fine.\r\n","created_at":"2008-08-12T00:43:39Z","content_type":"application/vnd.com.kenai.page.revision+json"}