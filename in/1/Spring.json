{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/Spring/revisions/1.json","name":"Spring","number":1,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/Spring.json","person":"john_brock","description":"","text":"There isn't much documentation about accessing JRuby from within Java, everyone seems to do things the other way around. However let's say you've a nice java web app or something similar and you're looking enviously at all those Rubyists wondering if these folks are getting the jump on you. Wouldn't it be great if we were able to simply replace little chunks of our java application with Ruby. Wouldn't it be a wonderful thing if we were able to delegate bits of our statically typed, rigid web application to a scripting language. You probably already do some of this with Velocity or Freemarker but those are typically just cosmetics, what you want is to be able to <strong>dynamically edit business logic</strong> on the fly. There are a few business rules engines out there, there's Droolz (now JBoss Java Rules) and various open and closed source BPM types of solutions. Nothing really has the buzz that Ruby has.\r\n\r\nThe spring docs actually miss the point of integration between Java and JRuby (I'm sure someone will sort that out), but in the meantime here's a neat way to integrate both technologies without creating dependencies on either side. <strong>It's cool!</strong>\r\n\r\nFirst you'll need this in your context xml. Mine is simply applicationContext-ruby.xml\r\n<pre>\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:lang=\"http://www.springframework.org/schema/lang\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\r\n        http://www.springframework.org/schema/lang\r\n        http://www.springframework.org/schema/lang/spring-lang-2.0.xsd\">\r\n\r\n    <lang:jruby id=\"messageService\"\r\n                script-interfaces=\"spike.Messenger\"\r\n                script-source=\"classpath:RubyMessenger.rb\">\r\n        <lang:property name=\"message\" value=\"Hello World!\"/>\r\n    </lang:jruby>\r\n\r\n</beans>\r\n</pre>\r\n\r\nWhat I'm asking Spring to do here is to wire up something found in the <code>RubyMessenger.rb</code> file, to my interface <code>spike.Messenger</code> and return me an instance of a Messenger. That instance will have a property set on it, by Spring. Take a look at my Messenger specification.\r\n\r\n<pre>\r\npackage spike;\r\n\r\npublic interface Messenger {\r\n    public String getMessage();\r\n}\r\n</pre>\r\n\r\nThe main thing to note here is that spring is setting the property in my bean, however from the Java side of things, there is no setter, nor constructor available; the values are injected via JRuby. Java has no idea that the implementation of Messenger is coming from Ruby. Let's look at that implementation:\r\n\r\n<pre>\r\nclass RubyMessenger\r\n    def setMessage(m)\r\n        @@message = m\r\n    end\r\n\r\n    def getMessage\r\n        @@message\r\n    end\r\nend\r\n\r\nRubyMessenger.new\r\n</pre>\r\n\r\nThe last line just avoids a bit of stress on the part of Spring by giving it an object to inspect and work with.\r\n\r\nThe most special thing about RubyMessenger.rb is that it is not special at all. It doesn't know that it's actually being injected into a Java framework. There's no <code>require 'java'</code> in there, it's pure, straight, unencumbered Ruby. Ruby that could run in a normal Ruby shell.\r\n\r\nNow isn't that just so cool? If you're integrating into an existing Java app, you can continue running all your unit tests and refactor classes into a completely different language. You can steal huge chunks of already written ruby libraries and applications and using a simple facade pattern, have those chunks of system working for you with no changes, no knowledge of the behind the scenes Java.\r\n\r\nHere's a snippet of code that executes the sample app above. To run it you'll need the spring.jar (v2.0.7), JRuby.jar (v1.0.1) and cglib-nodep.jar (v2.1_3):\r\n<pre>\r\npackage spike;\r\n\r\nimport org.springframework.beans.factory.BeanFactory;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class RubyRunner {\r\n    public static void main(String[] args) {\r\n        ApplicationContext context = new ClassPathXmlApplicationContext(\r\n                new String[]{\"applicationContext-ruby.xml\"});\r\n        BeanFactory factory = (BeanFactory) context;\r\n\r\n        Messenger m = (Messenger) factory.getBean(\"messageService\");\r\n        System.out.println(m.getMessage());\r\n    }\r\n}\r\n</pre>\r\n\r\nI'm actually delegating the functionality from my Java app where we load and manipulate a lot of huge text files. This is perfect because with a dynamic language behind the scenes we can patch up the production systems to deal with anomalies without re-deploying an entire website.\r\n\r\nNow what would be nice is for Spring to automatically map ruby accessors to Javabeans. Using the above example, Spring would bind <code>setMessage</code> to <code>message=()</code> and <code>getMessage</code> to the Ruby method <code>message</code>. In fact I think that would be so useful, I'm going to head over and ask the nice people as springframework.org to do just that.\r\n","created_at":"2008-08-12T20:51:55Z","content_type":"application/vnd.com.kenai.page.revision+json"}