{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/CallingJavaFromJRuby/revisions/19.json","name":"CallingJavaFromJRuby","number":19,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/CallingJavaFromJRuby.json","person":"daveray","description":"Fixed typo","text":"[[Home|&raquo; JRuby Project Wiki Home Page]]\n<h1>Scripting Java from JRuby</h1>\n__TOC__\n== An example ==\n\nAs of JRuby 1.0, a special <tt>require</tt> <tt>'java'</tt> directive in your file will give you access to the bundled Java libraries. However, this will ''not'' give you access to non-bundled libraries. A bit more is needed for that, which will be discussed later.\n\nAll the following examples can be tested using '''jirb_swing''', the Swing-based IRB console that comes with JRuby.\n\nThe following code shows this. Unless it was messed up while adding wiki tags, it should pop up a small window showing \"Hello\" on your screen.\n<pre name=\"ruby\">\n    # Valid as of JRuby 1.0\n    \n    # This is the 'magical Java require line'.\n    require 'java'\n    \n    # With the 'require' above, we can now refer to things that are part of the\n    # standard Java platform via their full paths.\n    frame = javax.swing.JFrame.new(\"Window\") # Creating a Java JFrame\n    label = javax.swing.JLabel.new(\"Hello\")\n    \n    # We can transparently call Java methods on Java objects, just as if they were defined in Ruby.\n    frame.getContentPane.add(label)  # Invoking the Java method 'getContentPane'.\n    frame.setDefaultCloseOperation(javax.swing.JFrame::EXIT_ON_CLOSE)\n    frame.pack\n    frame.setVisible(true)\n</pre>\n\n'''Note:''' If you are testing the example above in the Swing IRB console '''jirb_swing''', change the default close operation to DISPOSE_ON_CLOSE, or HIDE_ON_CLOSE unless you want '''jirb_swing''' to also close when you close the second window.\n\nHere's another example (showing results from testing these statements in the '''jirb''' console). \n\nLet's say you wanted to get a list of network interfaces. You can get Java API docs at <tt>[http://java.sun.com/j2se/1.5.0/docs/api/index.html/ java.net.NetworkInterface]</tt>. \n\nHere's how to access the methods from this Java Class from from JRuby:\n\n  irb(main):013:0> ni = java.net.NetworkInterface.networkInterfaces\n  => #<#<Class:01x7e666f>:0x855a27 @java_object=java.net.NetworkInterface$1@821453>\n\n'''<tt>ni</tt>''' is a Ruby variable holding a Java Enumeration of NetworkInterfaces. You can see the Class ancestry for <tt>ni</tt> like this:\n\n  irb(main):029:0> ni.class.ancestors\n  => [#<Class:01x7e666f>, Java::JavaUtil::Enumeration, Enumerable, Java::JavaLang::Object, \n  ConcreteJavaProxy, JavaProxy, JavaProxyMethods, Object, Java, Kernel]\n\nEnumeration elements can't be accessed using Array#[] syntax but they do appear as Arrays for many other purposes. You can find out both the Java and Ruby methods for an Enumeration of NetworkInterfaces like this:\n\n  irb(main):032:0> java.net.NetworkInterface.networkInterfaces.methods\n  => [\"__jsend!\", \"has_more_elements\", \"hasMoreElements\", \"next_element\", \"nextElement\",\n  \"each\", \"reject\", \"member?\", \"grep\", \"include?\", \"min\", \"sort\", \"any?\", \"partition\", \n  \"each_with_index\", \"collect\", \"find_all\", \"to_a\",  \"inject\", \"detect\", \"map\", \"zip\", \n  \"sort_by\", \"max\", \"entries\", \"all?\", \"find\", \"select\", \"hashCode\", \"notifyAll\", \n  \"getClass\", \"to_string\", \"toString\", \"get_class\", \"notify_all\", \"equals\", \n  \"hash_code\", \"wait\", \"notify\", \"__jcreate!\", \"java_class\", \"eql?\", \"synchronized\", \n  \"to_java_object\", \"equal?\", \"java_object\", \"java_object=\", \"to_s\", \"==\", \"hash\",\n  \"java_kind_of?\", \"handle_different_imports\", \"include_class\", \"display\", \n  \"object_id\", \"frozen?\", \"org\", \"__id__\", \"clone\", \"__send__\", \"id\", \"__jtrap\", \n  \"instance_eval\",  \"singleton_methods\", \"is_a?\", \"extend\", \n  \"instance_variable_set\", \"freeze\", \"remove_instance_variable\", \"=~\",\n  \"private_methods\", \"methods\", \"instance_variable_get\", \"nil?\", \"send\", \n  \"untaint\", \"com\", \"type\", \"class\", \"===\", \"instance_of?\", \n  \"protected_methods\", \"tainted?\", \"kind_of?\", \"javax\", \"inspect\", \"java\", \n  \"instance_exec\", \"taint\", \"dup\", \"public_methods\", \"instance_variable_defined?\", \n   \"respond_to?\", \"method\", \"instance_variables\"]\n\nBecause JRuby supports the <tt>#each</tt> method on Java Enumerations you can do this:\n\n  irb(main):011:0> java.net.NetworkInterface.networkInterfaces.each {|i| puts i; puts }\n  name:en1 (en1) index: 5 addresses:\n  /63.138.152.170;\n  /fe80:0:0:0:21b:63ff:febf:4a9d%5;\n  \n  name:en0 (en0) index: 4 addresses:\n  /63.138.152.125;\n  /fe80:0:0:0:21b:63ff:fe1e:b2da%4;\n  \n  name:lo0 (lo0) index: 1 addresses:\n  /127.0.0.1;\n  /fe80:0:0:0:0:0:0:1%1;\n  /0:0:0:0:0:0:0:1%0;\n\n== Accessing and Importing Java Classes ==\n\n=== Require a jar file to make resources in the jar discoverable within JRuby ===\nTo use resources within a jar file from JRuby, the jar file must either be on the classpath or be made available with the <tt>require</tt> method:\n\n  require 'path/to/mycode.jar'\n\nThis <tt>require</tt> makes the resources in <tt>mycode.jar</tt> discoverable by commands like <tt>import</tt> and <tt>include_package</tt>.\n\nNote that loading jar-files via <tt>require</tt> searches along the RUBYLIB path, like normal ruby files.\n\n=== Naming a Java Class ===\nYou can name a Java class in JRuby in at least three different ways. The idea is to map Java names like <tt>org.foo.department.Widget</tt> to Ruby nested modules. This works as follows:\n\n   Java: org.foo.department.Widget\n   Ruby: Java::OrgFooDepartment::Widget\n\nThat is:\n\n* Java packages reside in the <tt>Java</tt> module.\n* The package path is transformed by removing the dots and converting to ''CamelCase''\n\nThis also means that, just as in Java, packages are not nested.\n\n* For the top-level Java packages <tt>java</tt>, <tt>javax</tt>, <tt>org</tt>, and <tt>com</tt> you can type in a fully qualified class name basically as in Java, for example, <tt>java.lang.System</tt>.\n\nYou can get the same effect for your own top-level packages, as follows. Let's assume that your packages are called <tt>edu.school.department.Class</tt>. Then, you define\n\n   def edu\n      Java::Edu\n   end\n\nAnd you can use the usual Java package names.\n\nAs of JRuby-1.1.5, the <tt>import</tt> statement only works with either Java-style names or strings, but not with the <tt>Java::PackagePath::Class</tt> variant.\n\n=== Import a Java Class to Use It Without The Full Path Name ===\n\nYou can always access any Java class that has been loaded or is in the classpath by specifying its full name. With the <tt>java_import</tt> statement or <tt>import</tt> statement, you can make the Java class available only by its name, just as in Java.\n\n'''Example''': import and use the <tt>java.lang.System</tt> class.\n\n  require 'java'\n  java_import java.lang.System\n  version = System.getProperties[\"java.runtime.version\"]\n\n'''Note:''' As noted in [http://jira.codehaus.org/browse/JRUBY-3171 this bug report], <tt>java_import</tt> is the preferred, and safer, way to import Java classes.\n\n=== Use include_package within a Ruby Module to import a Java Package ===\n\nUse <tt>include_package \"package_name\"</tt> in a Ruby Module to support namespaced access to the Java classes in the package. It is also legal to use <tt>import \"package_name\"</tt>.\n\n'''Example''': create a Ruby Module called <tt>JavaLang</tt> that includes the classes in the Java package <tt>java.lang</tt>.\n\n  module JavaLang\n    include_package \"java.lang\"\n    # alternately, use the #import method\n    import \"java.lang\"\n  end\n\nPrefix the Class name with <tt>JavaLang::</tt> to access the included Classes:\n\n  version = JavaLang::System.getProperties[\"java.runtime.version\"]\n  => \"1.5.0_13-b05-237\"\n\n  processors = JavaLang::Runtime.getRuntime.availableProcessors\n  => 2\n\nThe Java classes in the package will become available in this class/module, unless a constant with the same name as a Java class is already defined.\n\nThe use of the Module name to scope access to the imported Java class is also helpful in cases where the Java class has the same name as an existing Ruby class. \n\nFor example if you need to create an instance of a <tt>java.io.File</tt> object, this code will work:\n\n  import java.io.File\n  newfile = File.new(\"file.txt\")\n  => #<Java::JavaIo::File:0xdc6f00 @java_object=file.txt>\n\nHowever you've now redefined the Ruby constant File and can no longer access the Ruby File class. Executing this:\n\n  File.open('README', 'r') {|f| puts f.readline }\n\nWill produce this error:\n\n  NoMethodError: private method `open' called for Java::JavaIo::File:Class\n\nIf instead you create a module called <tt>JavaIO</tt> and include the package in the module definition:\n\n  module JavaIO     \n    include_package \"java.io\"\n  end\n\nYou can now create a new instance of the Java class File without shadowing the Ruby version of the File class:\n\n  newfile = JavaIO::File.new(\"file.txt\")\n  => #<Java::JavaIo::File:0x15619c @java_object=file.txt>\n\nThe Ruby File class is still accessible:\n\n  File.open('README', 'r') {|f| puts f.readline }\n  JRuby -  A Java implementation of the Ruby language\n  => nil\n\n=== Accessing Java Enumerations ===\nJava <tt>enum</tt>s are accessible from Ruby code as constants:\n\n  lock.try_lock(5000, java.util.concurrent.TimeUnit::MILLISECONDS)\n\nor \n\n  java_import java.util.concurrent.TimeUnit\n  lock.try_lock(5000, TimeUnit::MILLISECONDS)\n\n=== Gotchas ===\n\nJRuby automatically binds the following names in the context of a class to the top-level Java packages: com, org, java, javax. This means that you can reference these packages without having to explicitly require or import them. This takes effect for all Ruby classes in an application where a require 'java' appears. This binding takes place in precedence to the classes \"method_missing\" handling.\n\nIf you do not want this behaviour for a specific class, you can undefine it for that class. Here's an example that will execute identically under Ruby and JRuby:\n\n<pre>\n# Note: Comment out for Ruby test. Uncomment for JRuby test.\nrequire 'java'\n\nclass MethodMissing\n  # JRuby: Undefine the standard \"automatic\" bindings to Java, to avoid any automatic binding.\n  undef org, com, java, javax\n  \n  def method_missing(m, *args)\n    puts \"method_missing: #{m}.\"\n    \"This is what I return from method missing.\"\n  end\nend\n\nmm = MethodMissing.new\nresult = mm.org\nputs \"Result: #{result} Type: #{result.class.name}\"\n</pre>\n\n== Calling a Java Method ==\n\n=== Alternative Names and Beans Convention ===\n\nIn Ruby, one usually prefers <tt>method_names_like_this</tt>, while Java traditionally uses <tt>methodNamesLikeThis</tt>. If you want, you can use Ruby-style method names instead of the Java ones.\n\nFor example, these two calls are equivalent\n\n  java.lang.System.currentTimeMillis\n  java.lang.System.current_time_millis\n\nJRuby also translates methods following the 'beans-convention':\n\n  x.getSomething            becomes   x.something\n  x.setSomething(newValue)  becomes   x.something = new_value\n  x.isSomething             becomes   x.something?\n\nYou don't have to use these alternatives, but they can make the interaction with Java code feel more Ruby-like.\n\n=== Beware of Java generics ===\n\nIf a Java class is defined with Java generics, the types are erased during compilation for backwards compatibility. As a result. JRuby will have problems with automatic type conversion. For example, if you have a <tt>Map<String,String></tt>, it will be seen as a simple <tt>Map</tt>, and JRuby will not be able to determine the correct types using reflection.\n\n=== Additional Methods ===\n\nJRuby defines a number of additional methods for Java objects.\n\n* <tt>java_class</tt> returns the Java class of an object.\n* <tt>java_kind_of?</tt> works like the <tt>instanceof</tt> operator.\n* <tt>java_object</tt> returns the underlying Java object. This is useful for reflection.\n* <tt>java_send</tt> overrides JRuby's dispatch rules and forces the execution of a named Java method on a Java object. This is useful for Java methods, such as <tt>initialize</tt>, with names that conflict with built-in Ruby methods. More below. ''Added in JRuby 1.4''\n* <tt>java_method</tt> retrieves a bound or unbound handle for a Java method to avoid the reflection inherent in <tt>java_send</tt>. More below. ''Added in JRuby 1.4''\n\n=== Calling masked or unreachable Java methods with <tt>java_send</tt> ===\nSometimes you need to call <tt>initialize</tt> AFTER the <tt>.new()</tt> call, for example the <tt>RTPManager</tt> class in JMF. Unfortunately, this method is masked by Ruby's <tt>initialize</tt> constructor method.  As of JRuby 1.4, the <tt>java_send</tt> method can be used to call this, and any other, masked method:\n\n  @mgr = javax.media.rtp.RTPManager.newInstance\n  localhost = java.net.InetAddress.getByName(\"127.0.0.1\")\n  localaddr = javax.media.rtp.SessionAddress.new(localhost, 21000, localhost, 21001)\n  @mgr.java_send :initialize, [javax.media.rtp.SessionAddress], localaddr\n\nIn previous versions of JRuby, the same thing can be accomplised with reflection:\n\n  @mgr = javax.media.rtp.RTPManager.newInstance\n  localhost = java.net.InetAddress.getByName(\"127.0.0.1\")\n  localaddr = javax.media.rtp.SessionAddress.new(localhost, 21000, localhost, 21001)\n  method = @mgr.java_class.declared_method(:initialize, javax.media.rtp.SessionAddress )\n  method.invoke @mgr.java_object, localaddr.java_object\n\nHere is another example of calling the <tt>ArrayList.add</tt> method with <tt>java_send</tt>:\n\n \n import java.util.ArrayList\n list = ArrayList.new\n list.java_send :add, [Java::int, java.lang.Object], 0, 'foo'\n puts list.java_send :toString # => \"[foo]\"\n\nNote the second argument, which is an array of types indicating the exact method signature desired. This is useful for disambiguating methods that are overloaded on similar types such as <tt>int</tt> and <tt>long</tt>.\n\n=== Bound and Unbound Java methods with <tt>java_method</tt> ===\n<tt>java_send</tt> relies on reflection and may lead to poor performance in some cases. Each time it is called, the desired method must be relocated. With the <tt>java_method</tt> method you can get a reference to any overloaded Java method as a Ruby Method object:\n\n \n # get a bound Method based on the add(int, Object) method from ArrayList\n add = list.java_method :add, [Java::int, java.lang.Object]\n add.call(0, 'foo')\n \n\nSimilarly, an Unbound method object can be retrieved:\n\n # get an UnboundMethod from the ArrayList class:\n toString = ArrayList.java_method :toString\n toString.bind(list).call # => [foo, foo]\n\n=== Conversion of Types ===\n\n==== Ruby to Java ====\n\n''See the JRuby rspec source code dir'' <tt>spec/java_integration</tt> ''for many more examples.''\n\nWhen calling Java from JRuby, primitive Ruby types are converted to default boxed Java types:\n\n{| border=\"1\" style=\"text-align:left;\" cellspacing=\"2\" cellpadding=\"5\" \n|- style=\"background:silver\"\n|'''Ruby Type'''\n|'''Java Type'''\n|- \n|  \"foo\" || <tt>java.lang.String</tt>\n|-\n| 1 || <tt>java.lang.Long</tt>\n|-\n| 1.0 || <tt>java.lang.Double</tt>\n|-\n| true, false || <tt>java.lang.Boolean</tt>\n|-\n| 1 << 128 || <tt>java.math.BigInteger</tt> \n|}\n\nHowever, this does not mean that you cannot call methods expecting a primitive type. You can also pass an integer to a method expecting a double value. JRuby usually tries quite hard to find a method that can understand your parameters.\n\nIf JRuby cannot find a matching method, it tries to pass the actual JRuby objects instead (that is, the Java objects from the JRuby implementation). A consequence of this is that if this fails you will see an error message stating that JRuby hasn't found a method taking an object of class <tt>org.jruby.RubyObject</tt> instead of the actual type.\n\nIf JRuby is not finding the exact method you want to call, perhaps because of extreme ambiguity like <tt>foo(int)</tt> vs. <tt>foo(long)</tt>, the <tt>java_send</tt> method can be used to disambiguate. See below.\n\n==== Java to Ruby ====\nWhen primitive Java types are passed to JRuby they are converted to the following Ruby types:\n\n{| border=\"1\" style=\"text-align:left;\" cellspacing=\"2\" cellpadding=\"5\" \n|- style=\"background:silver\"\n|'''Java Type'''||'''Ruby Type'''\n|- \n| <tt>public String</tt> || <tt>String</tt>\n|-\n| <tt>public byte</tt> || <tt>Fixnum</tt>\n|-\n| <tt>public short</tt> || <tt>Fixnum</tt>\n|-\n| <tt>public char</tt> || <tt>Fixnum</tt>\n|-\n| <tt>public int</tt> || <tt>Fixnum</tt>\n|-\n| <tt>public long</tt> || <tt>Fixnum</tt>\n|-\n| <tt>public float</tt> || <tt>Float</tt>\n|-\n| <tt>public double</tt> || <tt>Float</tt>\n|}\n\nThe Java Booleans true and false are coerced to the Ruby singleton classes TrueClass and FalseClass which are represented in Ruby with the instances true and false.\n\nThe null Java object is coerced to the Ruby class NilClass which is represented in Ruby as the instance nil.\n\n==== Java Primitive Classes ====\n\nJava primitive classes can be found in the Java module. For example, <code>Java::byte</code> represents the primitive type byte in java. You can get its class as follows:\n\n{| border=\"1\" \n|- style=\"background:silver\"\n|'''Ruby Code''' ||'''Java Class''' \n|- \n| <tt>Java::JavaClass.for_name(\"byte\") </tt> || <tt>Java::byte.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"boolean\") </tt> || <tt> Java::boolean.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"byte\") </tt> || <tt> Java::byte.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"short\") </tt> || <tt> Java::short.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"char\") </tt> || <tt> Java::char.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"int\") </tt> || <tt> Java::int.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"long\") </tt> || <tt> Java::long.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"float\") </tt> || <tt> Java::float.java_class</tt>\n|- \n| <tt>Java::JavaClass.for_name(\"double\") </tt> || <tt> Java::double.java_class</tt>\n|}\n\n== Arrays ==\nThere are two ways of constructing Java arrays. One is to use the <code>to_java</code> method of the class Array. The other is to use the <tt>[]</tt> method for the primitive Java types.\n\n==== Converting a Ruby Array to a Java Array ====\nThe <tt>to_java</tt> method constructs a Java array from a Ruby array:\n\n  [1,2,3].to_java\n  => [Ljava.lang.Object;@1a32ea4\n\nBy default, <tt>to_java</tt> constructs <tt>Object</tt> arrays. You can specify the parameter with an additional argument which can either be a symbol or a primitive class like <tt>Java::double</tt>\n\n  [\"a\",\"b\",\"c\"].to_java(:string)\n  => [Ljava.lang.String;@170984c\n\n  [1, 2, 3.5].to_java Java::double\n  => [D@9bc984\n\n==== Constructing Empty Java Arrays ====\nSometimes a Java library will need a fixed-length array, say for example a byte buffer for a stream to read into. For this, you can use the <tt>[]</tt> method of the primitive types in the Java module:\n\n  bytes = Java::byte[1024].new # Equivalent to Java's bytes = new byte[1024];\n\n=== Ruby String to Java Bytes and back again ===\n  bytes = 'a string'.to_java_bytes\n  => #<#<Class:01x9fcffd>:0x40e825 @java_object=[B@3d476c>\n\n  string = String.from_java_bytes bytes\n  => \"a string\"\n\n=== Convert a Java InputStream to a ruby IO object ===\n\n  io = Java.java_to_ruby(org.jruby.RubyIO.new(JRuby.runtime, input_stream).java_object)\n\n[http://logs.jruby.org/jruby/2009-06-23.html#T21-34-32 from ribrdb on irc]\n \n\n== Referencing a <tt>java.lang.Class</tt> object ==\nIf you call a Java class from JRuby and need to pass a Java class as an argument, if you use this form:\n\n  DoSomethingWithJavaClass(MyJavaClass.class)\n\nyou'll get this error:\n\n  TypeError: expected [java.lang.Class]; \n  got: [org.jruby.RubyClass]; error: argument type mismatch\n\nInstead use the method <tt>java_class</tt>.\n\n  DoSomethingWithJavaClass(MyJavaClass.java_class)\n\n== Integrating JRuby and Java Classes and Interfaces ==\n=== Classes ===\n==== Reopening Java Classes ====\nIn Ruby, classes are always open, which means that you can later add methods to existing classes. This also works with Java classes.\n\nThis comes in handy when adding syntactic sugar like overloaded operators to Java classes, or other methods to make them behave more Ruby-like.\n\nNote that these additions will only be visible on the JRuby side. \n\n==== Subclassing a Java class ====\nYou can subclass (i.e. extend) a Java class and then use the JRuby class whenever Java expects the superclass.\n\n==== Gotchas ====\nIf you have a class name ambiguity between Java and Ruby, the class name will reference the Ruby construct within the Ruby code. For instance, if you import <tt>java.lang.Thread</tt> and then write <tt>JThread < Thread</tt>, <tt>JThread</tt> will in fact inherit the Ruby <tt>Thread</tt> object, not the Java <tt>Thread</tt>. The solution is to use the full Java Class name, such as:\n JThread < java.lang.Thread\n\n=== Interfaces ===\nJava interfaces are mapped to modules in JRuby. This means that you can also reopen the corresponding module and add further methods on the JRuby side.\n\n==== Implementing Java Interfaces in JRuby ====\nJRuby classes can now implement more than one Java interface. Since Java interfaces are mapped to modules in JRuby, you implement them not by subclassing, but by mixing them in.\n\n  class SomeJRubyObject\n    include java.lang.Runnable\n    include java.lang.Comparable\n  end\n\n==== Closure conversion ====\nJRuby sports a feature called ''closure conversion'', where a Ruby block or closure is converted to an appropriate Java interface. For example:\n\n  button = javax.swing.JButton.new \"Press me!\"\n  button.add_action_listener {|event| event.source.text = \"You did it!\"}\n\nIn this example, the <tt>JButton</tt>'s <tt>addActionListener</tt> method takes one parameter, a <tt>java.awt.event.ActionListener</tt>. The block is converted to a <tt>Proc</tt> object, which is then decorated with a java interface proxy that invokes the block for any method called on the interface.\n\nThis not only works for event listeners or <tt>Runnable</tt>, but basically for any interface. When calling a method that expects an interface, JRuby checks if a block is passed and automatically converts the block to an object implementing the interface.\n\n \n\n=== Java classes can't inherit from a JRuby class ===\nHopefully this feature will be added in the planned re-write of the Java integration layer in a future release of JRuby.\n\n== Synchronization in JRuby ==\nWhen interacting with Java APIs from JRuby, it is occasionally necessary to synchronize on an object for thread safety. In JRuby, a <tt>synchronize</tt> method is provided on every wrapped Java object to support this functionality. For example, the following Java code:\n\n \n synchronized(obj) {\n     obj.wait(1000); \n }\n \n\nis implement like this in Ruby:\n\n \n obj.synchronized do\n     obj.wait 1000\n end\n \nThe expression evaluates to the result of the block, e.g.,\n\n \n obj.synchronized { 99 }  # => 99\n \n\n== Material from Before JRuby 1.0 ==\nOne powerful feature of JRuby is its ability to invoke the classes of the Java Platform. The following example uses JRuby 0.9.2 to create a Java <tt>JFrame</tt> with a <tt>JLabel</tt>. \n\n'''Note:''' Several package paths are magic: <tt>java</tt>, <tt>javax</tt>, <tt>org</tt>, <tt>com</tt>.  Many package paths will need to be prefixed with <tt>Java</tt>:\n\n<pre name=\"ruby\">\nrequire 'java'\n\nJFrame = javax.swing.JFrame\nJLabel = javax.swing.JLabel\n\nframe = JFrame.new()\nframe.getContentPane().add(JLabel.new(\"This is an example.\"))\nframe.pack()\nframe.setVisible(true)\n\nMyClass = Java::my.package.MyClass\nmyClass = MyClass.new()\nmyClass.doit()\n</pre>\n\n'''Note:''' Older versions of JRuby require you to use the following code as the import preamble:\n\n<pre name=\"ruby\">\nrequire 'java'\n\ninclude_class \"javax.swing.JFrame\"\ninclude_class \"javax.swing.JLabel\"\n</pre>\n\nJRuby also allows you to call Java code by using the more Ruby-like <tt>underscore_method_naming</tt> and to refer to JavaBean properties as attributes. The translation rule is that the Java method name is split by capital letters, lowercased, and prepended with <tt>_</tt>.\n<pre name=\"ruby\">\nframe.content_pane.add(label)\nframe.visible = true\n</pre>\n\nJRuby also lets you call Java libraries ''not'' included in the standard set of class libraries associated with the Java Platform. By copying jars to <tt>$JRUBY_HOME/lib</tt> or by modifying the CLASSPATH environment variable, you can access third-party Java libraries from JRuby scripts or from jirb, an interactive JRuby shell. It is also possible to add a jar to the classpath by requiring the jar (if it exists in the JRuby library load path):\n<pre name=\"ruby\">\nrequire 'whatever.jar'\ncom.whatever.Whatever.doSomething\n</pre>\n\n== Related Articles ==\n* [http://mikiobraun.blogspot.com/2008/11/java-integration-in-jruby.html Java Integration in JRuby] Short overview article on JRuby and Java integration.\n* [http://blogs.sun.com/sundararajan/entry/java_integration_javascript_groovy_and Java Integration: JavaScript, Groovy and JRuby] Side-by-side comparison of Java integration in JavaScript, Groovy and JRuby.\n* [http://jruby.codehaus.org/Java+Integration Java Integration] From the JRuby main page.\n* [http://jtestr.codehaus.org/ JtestR] A testing framework for Java based on JRuby.\n* [http://github.com/leandrosilva/sparrow Sparrow] A JMS client for messaging based on JRuby.\n\n","created_at":"2009-12-01T02:36:31Z","content_type":"application/vnd.com.kenai.page.revision+json"}