{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/GettingStarted/revisions/36.json","name":"GettingStarted","number":36,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/GettingStarted.json","person":"pfussell","description":"changed download URL to http://jruby.org/download ","text":"[[Home|&raquo; JRuby Project Wiki Home Page]]\n<h1>Getting Started with JRuby</h1>\nTo get JRuby on your system, install a binary file for your system and then work with it from the command line in a terminal window or command window.\n__TOC__\n==Installing JRuby==\nThe easiest way to get up and running with JRuby is to download the latest binary, extract it, and add the directory to your PATH environment variable. \n\n'''Note:''' It's best to avoid using a package manager because of issues with keeping the downloaded versions current.\n\nIf you prefer to build your own JRuby, see [[DownloadAndBuildJRuby|Downloading JRuby Source and Building It Yourself]].\n\n'''To download and install JRuby:'''\n# [http://jruby.org/download Download a JRuby binary file]. \n#* For OSX, Linux, BSD, Solaris, and other UNIX varieties, get the most recent <tt>jruby-bin-X.Y.Z.tar.gz</tt> file.\n#* If you're on Microsoft Windows, get the most recent <tt>jruby-bin-X.Y.Z.zip</tt> file.\n# Extract JRuby into a directory.\n# Add that directory's bin subdirectory to the ''end'' of your <tt>PATH</tt> environment variable.\n#* On OSX, Linux, BSD, Solaris, and other UNIXes, the variable is '''$PATH''', and a sample JRuby path is <tt>/opt/jruby/bin</tt>.\n#* On Microsoft Windows, the variable is '''%PATH%''', and a sample JRuby path is <tt>C:\\JRuby\\jruby-1.3.0\\bin</tt>.<br/> Also, make sure your <tt>JAVA_HOME</tt> environment variable points to your Java installation. For example, <tt>C:\\Program Files\\Java\\jdk1.6.0_14\\</tt>.\n\n'''Note:''' On some versions of Linux, you'll need to get the right version of Java installed. For more infomation, see [[JRubyOnUbuntu|JRuby With Wrong Java]].\n\n'''Note:''' If you're on HP-UX, see [[JRubyOnHPUX11_23|Using JRuby on HPUX]].\n\n===Linux and OSX Installation Example===\nOnce you've downloaded or built a JRuby installation and it is located in the directory <tt>/opt/jruby</tt>,\nyou'll need to add <tt>/opt/jruby/bin</tt> to the end of your <tt>$PATH</tt> environment variable.\n\nOn Mac OS X and Linux, you can add to the <tt>PATH</tt> variable with the export command:\n  export PATH=$PATH:/opt/local/bin\n\n===Microsoft Windows XP Installation Example===\nOnce you've downloaded or built a JRuby installation and it is located in the directory <tt>C:\\JRuby\\jruby1.3.0\\</tt>,\nyou'll need to add <tt>C:\\JRuby\\jruby1.3.0\\bin</tt> to the end of your <tt>%PATH%</tt> environment variable. You'll also need to ensure that your <tt>JAVA_HOME</tt> variable is set to the location of your current Java installation, for example, <tt>C:\\Program Files\\Java\\jdk1.6.0_14\\</tt>.\n# In Windows XP, choose Start > Control Panel > System to open the System Properties window.\n# Click the Advanced tab, then click the Environment Variables button at the bottom of the window.\n# In the System Variables section, scroll down to <tt>Path</tt>, select it, and click Edit.\n# Add the path to the JRuby bin directory to the end of the Path. For example, add:<br/>;<tt>C:\\JRuby\\jruby1.3.0\\bin</tt>\n# Look for <tt>JAVA_HOME</tt> in both the User Variables section and the System Variables section and make sure it points to your current Java installation. If necessary, create a new JAVA_HOME variable as follows:\n## Under the User Variables section, click New.\n##* '''Variable name:''' enter <tt>JAVA_HOME</tt>\n##* '''Variable value:''' enter the actual path. For example, <br/> <tt>C:\\Program Files\\Java\\jdk1.6.0_14\\</tt>.\n## Click OK to add the variable.\n# Click OK at the bottom of the Environment Variables window.\n# Click OK to close the System Properties window.\n\n==Did It Work?==\nTo test whether JRuby installed correctly, open a command window or terminal window and run:\n  jruby -v\n\nIf it installed correctly, JRuby will return the current version.\n\n==How Do I Run rake, gem, etc?==\nThe recommended way to run these commands (known as ''system-level executable commands'') in JRuby is to '''always''' use <tt>jruby -S</tt>.\n\n  jruby -S gem list --local\n  jruby -S gem install rails mongrel jdbc-mysql activerecord-jdbcmysql-adapter\n  jruby -S rails blog\n  cd blog\n  jruby -S rake -T\n  jruby -S rake db:migrate\n\nThe <tt>-S</tt> parameter tells JRuby to use '''its''' version of the installed binary.\n\n==How Do I Run a Ruby Program?==\nTo run any other ruby program by using JRuby, run it using the <tt>jruby</tt> command in a command window. For example,\n\n  jruby script/server\n  jruby my_ruby_script.rb\n\n'''See Also:''' [[JRubyCommandLineParameters|JRuby Command Line Parameters]]\n\n== jirb: Ruby Interactive Console ==\nOne of the few standard Ruby utilities that has a different name in JRuby than in C Ruby is the command for the interactive Ruby console: <tt>'''jirb'''</tt>. In C Ruby this utility is simply called <tt>irb</tt>.\n\nTo enable tab completion within jirb, add the following line to the configuration file .irbrc:\n  require 'irb/completion'\n\n'''Note:''' If you're on Linux, BSD, OSX, Solaris, and other UNIXes, the .irbrc file must be in your home directory. If you're on Windows, it goes in your My Documents folder or the folder specified in the HOME environment variable.\n\n'''See Also:''' [[JirbCommandLineParameters|Jirb Command Line Parameters]]\n\n==Installing and Using Ruby Gems==\nThe RubyGems can be easily installed with JRuby with the following command:\n jruby -S gem install rails mongrel jdbc-mysql activerecord-jdbcmysql-adapter\n\nMany Gems will work fine in JRuby; however, some Gems build native C libraries as part of their install process. These Gems will not work in JRuby unless the Gem has also provided a Java equivalent to the native library. \n\nMongrel and Hpricot are two examples of Gems that build their native library in a platform independent manner. Each of them specify a parsing library using the Ragel language and a Ragel program can be automatically converted into either C or Java as part of the compile process.\n\nAlso, keep in mind that installing gems from behind a firewall will require setting the HTTP_PROXY. For example:\n\nNot authenticated:<br/>\n<tt> &nbsp;<nowiki>export http_proxy=http://${http-proxy-host}:${http-proxy-port}/</nowiki></tt> <br/>\nAuthenticated:<br/>\n<tt> &nbsp;<nowiki>export http_proxy=http://{your_user_id}:{your_password}@${http-proxy-host}:${http-proxy-port}/</nowiki></tt>\n\nSee also [[Troubleshooting]].\n\n==Benchmarking==\nThe current popular way to benchmark JRuby performance is to perform a gem installation of Rake. The install process exercises a number of APIs and represents a fairly general-purpose application of Ruby. It's also extremely interpreter-heavy.\n\nAfter getting a build of JRuby, as above, the following steps can be used to benchmark JRuby using Gem and Rake:\n\n*Fetch the current Rake gem from [http://rubyforge.org/frs/?group_id=50 RubyForge]\n*Execute the following command (putting JRUBY_HOME/bin in your path or referencing it directly):\n JRUBY_HOME/bin/gem install <rake gem file>\n*By preceding this command line with the unix \"time\" command you can test end-to-end performance. Of course there are other ways to wire in profiling and performance-monitoring tools that won't be detailed here.\n\nA sample run from a MacBook Pro under Apple's Java 6 JVM is shown below:\n\n Nutters-Computer:~/Documents/workspace/jruby headius$ time bin/gem install rake-0.7.1.gem \n Successfully installed rake, version 0.7.1\n Installing ri documentation for rake-0.7.1...\n Installing RDoc documentation for rake-0.7.1...\n \n real    0m52.596s\n user    0m51.740s\n sys     0m2.146s\n\n==Code Examples==\nBelow are some code examples showing how to call ruby from within Java and Java from ruby.\n\n===Ruby:  <tt>call_java.rb</tt>===\n  require \"java\"\n  \n  include_class \"java.util.TreeSet\"\n  include_class \"com.example.CallMe\"\n  include_class \"com.example.ISpeaker\"\n  \n  puts \"Hello from ruby\"\n  set = TreeSet.new\n  set.add \"foo\"\n  set.add \"Bar\"\n  set.add \"baz\"\n  set.each { |v| puts \"value: #{v}\" }\n  \n  cm = CallMe.new\n  cm.hello\n  $globalCM.hello\n  \n  class CallJava\n    include ISpeaker\n    def initialize\n      super\n      @count = 0\n    end\n  \n    def say(msg)\n      puts \"Ruby saying #{msg}\"\n    end\n    \n    def addOne(from)\n  #    m.synchronize {\n        @count += 1\n        puts \"Now got #@count from #{from}\"\n  #    }\n    end\n  end\n\n===Java: <tt>ISpeaker.java</tt>===\n    package com.example;\n    \n    public interface ISpeaker {\n        public void say(String msg);\n        \n        public void addOne(String from);\n    }\n\n===Java: <tt>CallMe.java</tt>===\n\n    package com.example;\n    \n    public class CallMe {\n    \n        String mName;\n    \n        public CallMe() {\n            this(\"Default\");\n        }\n        \n        public CallMe(String name) {\n            mName = name;\n        }\n        \n        public void hello() {\n            System.out.println(\"Hello from \"+mName);\n        }\n        \n        public static void main(String []args) {\n            System.out.println(\"Called main\");\n        }\n    }\n\n===Java: <tt>CallRuby.java</tt>===\n    package com.example;\n    \n    import org.apache.bsf.BSFManager;\n    import org.apache.bsf.util.IOUtils;\n    import org.jruby.Ruby;\n    import org.jruby.javasupport.Java;\n    import org.jruby.javasupport.JavaEmbedUtils;\n    import org.jruby.javasupport.JavaUtil;\n    import org.jruby.runtime.Block;\n    import org.jruby.runtime.GlobalVariable;\n    import org.jruby.runtime.builtin.IRubyObject;\n    \n    import java.io.FileReader;\n    import java.io.IOException;\n    \n    /**\n     * Example of how to:\n     * 1. Use java objects in ruby\n     * 2. Subclass/implement java objects in ruby\n     * 3. Get ruby objects for use in java world\n     * 4. Proxy ruby objects for normal use as java objects (interfaces/class)\n     */\n    public class CallRuby {\n    \n        public static void main(String[] args) throws Exception {\n    \n            String dir = \"/dclark/workspace/jrubytest/ruby/\";\n    \n            double[] deltas = new double[3];\n            for (int i = 0; i < 3; i++) {\n                boolean useBSF = (i == 0);\n                long start = System.currentTimeMillis();\n    \n                if (useBSF) {\n                    //--- Initialise ruby\n                    BSFManager.registerScriptingEngine(\"ruby\", \"org.jruby.javasupport.bsf.JRubyEngine\", new String[]{\"rb\"});\n                    BSFManager manager = new BSFManager();\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    manager.declareBean(\"globalCM\", javaCallMe, javaCallMe.getClass());\n    \n                    //--- Load a ruby file\n                    manager.exec(\"ruby\", \"call_java.rb\", -1, -1, getFileContents(dir + \"call_java.rb\"));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    ISpeaker ruby = (ISpeaker) manager.eval(\"ruby\", \"call_java.rb\", -1, -1, expr);\n    \n                    testMultiThreadsCallingRubyObject(ruby);\n    \n                } else {\n    \n                    //--- Initialise ruby\n                    final Ruby runtime = Ruby.getDefaultInstance();\n    \n                    // Need the blank object so can get a nice runtime for the Java.staticMethods calls\n                    runtime.eval(runtime.parse(\"require \\\"java\\\"\\nclass BlankForJva\\nend\\n\", \"BlankForJva.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n                    final IRubyObject blankRuby = runtime.evalScript(\"BlankForJva.new\");\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    IRubyObject globValue = JavaUtil.convertJavaToRuby(runtime, javaCallMe);\n    \n                    // Wrap so that all methods are visible to ruby\n                    globValue = Java.java_to_ruby(blankRuby, globValue, Block.NULL_BLOCK);\n    \n                    GlobalVariable globVar = new GlobalVariable(runtime, \"$globalCM\", globValue);\n                    runtime.defineVariable(globVar);\n    \n                    //--- Load a ruby file\n                    runtime.eval(runtime.parse(getFileContents(dir + \"call_java.rb\"), \"call_java.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    final IRubyObject rawRuby = runtime.evalScript(expr);\n                    ISpeaker ruby;\n                    if (i == 1) {\n                        // Standard wrapper using Java Proxies\n                        ruby = (ISpeaker) JavaEmbedUtils.rubyToJava(runtime, rawRuby, ISpeaker.class);\n                    } else {\n                        // Or manually wrap ruby object so can be used as the interface (can optionally add synchronization as required on methods)\n                        ruby = new ISpeaker() {\n                            public void addOne(String from) {\n                                //                            synchronized (rawRuby) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"addOne\", JavaUtil.convertJavaToRuby(runtime, from));\n                                //                            }\n                            }\n    \n                            public void say(String msg) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"say\", JavaUtil.convertJavaToRuby(runtime, msg));\n                            }\n                        };\n                    }\n                    testMultiThreadsCallingRubyObject(ruby);\n                }\n                long end = System.currentTimeMillis();\n                deltas[i] = (end - start) / 1000.0;\n            }\n    \n            for (int i = 0; i < deltas.length; i++) {\n                System.out.println(\"Took \" + deltas[i] + \" on pass \" + i);\n            }\n        }\n    \n        private static String getFileContents(String filename) throws IOException {\n            FileReader in = new FileReader(filename);\n            return IOUtils.getStringFromReader(in);\n        }\n    \n        public static void testMultiThreadsCallingRubyObject(final ISpeaker ruby) throws InterruptedException {\n            Thread t1 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t1\");\n                    }\n                }\n            });\n            Thread t2 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t2\");\n                    }\n                }\n            });\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            ruby.addOne(\"end\");\n        }\n    }\n\n'''Note:''' If you have only simple interface requirements, you can use the second method of proxying the ruby object to include method level synchronization.\n\n'''Note:''' BSF calling does not preserve ruby stack traces (add an error to a script and run both ways using the code above).\n\n'''Note Also:''' The times you get from running this example are interesting (on my old Windows box using Java5):\n\n  Took 5.469 on pass 0  // This is the Standard BSF Wrapping\n  Took 1.75 on pass 1   // Using normal Java Proxies\n  Took 1.359 on pass 2  // Rolling your own redirector class to call Ruby\n","created_at":"2009-06-19T19:52:57Z","content_type":"application/vnd.com.kenai.page.revision+json"}