{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/GettingStarted/revisions/17.json","name":"GettingStarted","number":17,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/GettingStarted.json","person":"pfussell","description":"Moved Downloading Source section up higher","text":"<h1>Getting Started with JRuby</h1>\nTo get JRuby on your system, you can either install a binary file for your system, or you can download and build JRuby yourself.\n__TOC__\n==Installing JRuby==\nGetting up and running with JRuby is very easy. You can either use your operating system's package manager, or if you're on Windows or your package manager doesn't include JRuby, you can use a three-step process to download, extract, and add the directory to your PATH environment variable. \n===Install With Package Manager===\nThe easiest way to get started with JRuby is to use your operating system's package manager. \n*'''MacPorts:''' <tt>sudo port install jruby</tt>\n*'''Emerge:''' <tt>emerge jruby</tt>\n*'''apt-get:''' <tt>apt-get install jruby</tt>\n*'''yum:''' <tt>yum install jruby</tt>\nOnce you're done, go to [[#Did_it_work|Did it work?]] to continue.\n\n===Download and Install Yourself===\nIf you're on Windows, or if your package manager doesn't include JRuby you'll need to extract it yourself.\n\n# [http://dist.codehaus.org/jruby/ Download JRuby]. Grab the most recent jruby-bin-X.Y.Z.tar.gz or .zip.\n# Extract JRuby into a directory.\n# Add that directory's bin subdirectory to the ''end'' of your <tt>path</tt> environment variable.\n#* On OSX, Linux, BSD, Solaris, and other UNIXes, the variable is '''$PATH''', and the JRuby path might be <tt>/opt/jruby1.3/bin</tt>.\n#* On Microsoft Windows, the variable is '''%PATH%''', and the JRuby path might be <tt>C:\\JRuby\\jruby-1.3\\bin</tt>.<br/> Also, make sure your <tt>JAVA_HOME</tt> environment variable points to your Java installation. For example, <tt>C:\\Program Files\\Java\\jdk1.6.0_14\\</tt>\n\n'''Note:''' On some versions of Linux, you'll need to get the right version of Java installed. For more infomation, see [[JRubyOnUbuntu|JRuby with wrong Java]].\n\n'''Note:''' If you're on HP-UX, see [[JRubyOnHPUX11_23|Using JRuby on HPUX]].\n\n====Installation Examples====\n'''UNIXes: Linux, OSX, BSD, Solaris Example'''\n\nOnce you've downloaded or built a JRuby installation and it is located in the directory <tt> /opt/jruby</tt>,\nyou'll need to add <tt>/opt/jruby/bin</tt> to the end of your <tt>$PATH</tt> environment variable.\n\nOn Mac OS X and Linux, you can add to the <tt>PATH</tt> variable with the export command:\n  export PATH=$PATH:/opt/local/bin\n\n'''Microsoft Windows XP Example'''\n\nOnce you've downloaded or built a JRuby installation and it is located in the directory <tt>C:\\JRuby\\jruby1.3\\</tt>,\nyou'll need to add <tt>C:\\JRuby\\jruby1.3\\bin</tt> to the end of your <tt>%PATH%</tt> environment variable. You'll also need to ensure that your <tt>JAVA_HOME</tt> variable is set to the location of your current Java installation, for example, <tt>C:\\Program Files\\Java\\jdk1.6.0_14\\</tt>.\n# In Windows XP, choose Start > Control Panel > System to open the System Properties window.\n# Click the Advanced tab, then click the Environment Variables button at the bottom of the window.\n# In the System Variables section, scroll down to <tt>Path</tt> and click Edit.\n# Add the path to the JRuby bin directory to the end of the path. For example, add:<br/>;<tt>C:\\JRuby\\jruby1.3\\bin</tt>\n# Look for <tt>JAVA_HOME</tt> in both the User Variables section and the System Variables section and make sure it points to your current Java installation. If necessary, create a new JAVA_HOME variable as follows:\n## Under the User Variables section, click New.\n##* '''Variable name:''' enter <tt>JAVA_HOME</tt>\n##* '''Variable value:''' enter the actual path. For example, <br/> <tt>C:\\Program Files\\Java\\jdk1.6.0_14\\</tt>.\n## Click OK to add the variable.\n# Click OK at the bottom of the Environment Variables window.\n# Click OK to close the System Properties window.\n\n==Downloading Source and Building Yourself==\nThe JRuby source code is available in a git repository. Retrieve the trunk version of the JRuby source and build JRuby using the following shell commands ('''Note:''' Ant 1.7 is required to build JRuby version greater than 1.1):\n git clone git://kenai.com/jruby~main jruby\n cd jruby\n ant\n\nCreate an up-to-date version of <tt>jruby-complete.jar</tt> with this ant task: \n ant jar-complete\n\nGenerate an up-to-date set of the JavaDoc for JRuby located here: <tt>docs/api/index.html</tt>:\n ant create-apidocs\n\nDelete any build and compile artifacts:\n  ant clean\n\nRun the JRuby tests:\n  ant test\n\n==Did It Work?==\nTo test whether JRuby installed correctly, open a command window and run:\n  jruby -v\n\nIf it installed correctly, JRuby will return the current version.\n\n==How Do I Run rake, gem, etc?==\nThe recommended way to run these commands (known as ''system-level executable commands'') in JRuby is to '''always''' use ''jruby -S''\n\n  jruby -S gem list --local\n  jruby -S gem install rails mongrel jdbc-mysql activerecord-jdbcmysql-adapter\n  jruby -S rails blog\n  cd blog\n  jruby -S rake -T\n  jruby -S rake db:migrate\n\nThe <tt>-S</tt> parameter tells JRuby to use '''its''' version of the installed binary.\n\n==How Do I Run a Ruby Program?==\n\nTo run any other ruby program using JRuby, run it using the <tt>jruby</tt> command in a command window. For example,\n\n  jruby script/server\n  jruby my_ruby_script.rb\n\n== jirb: Ruby Interactive Console ==\nOne of the few standard Ruby utilities that has a different name in JRuby than in C Ruby is the command for the interactive Ruby console: <tt>'''jirb'''</tt>. In C Ruby this utility is simply called <tt>irb</tt>.\n\nTo enable tab completion within jirb:\n  require 'irb/completion'\n\n==Installing and Using Gems in JRuby==\nThe RubyGems can be easily installed with JRuby with the following command:\n jruby -S gem install rails mongrel jdbc-mysql activerecord-jdbcmysql-adapter\n\nMany Gems will work fine in JRuby; however, some Gems build native C libraries as part of their install process. These Gems will not work in JRuby unless the Gem has also provided a Java equivalent to the native library. \n\nMongrel and Hpricot are two examples of Gems that build their native library in a platform independent manner. Each of them specify a parsing library using the Ragel language and a Ragel program can be automatically converted into either C or Java as part of the compile process.\n\nAlso, keep in mind that installing gems from behind a firewall will require setting the HTTP_PROXY (e.g.  <nowiki>export http_proxy=http://${http-proxy-host}:${http-proxy-port}/</nowiki> or <nowiki>export http_proxy=http://{your_user_id}:{your_password}@${http-proxy-host}:${http-proxy-port}/</nowiki> if it's authenticated)\n \nSee also [[Troubleshooting]].\n\n==JRuby Command Parameters==\n\n  $ jruby --help\n  Usage: jruby [switches] [--] [programfile] [arguments]\n    -0[octal]       specify record separator (, if no argument)\n    -a              autosplit mode with -n or -p (splits $_ into $F)\n    -b              benchmark mode, times the script execution\n    -c              check syntax only\n    -Cdirectory     cd to directory, before executing your script\n    -d              set debugging flags (set $DEBUG to true)\n    -e 'command'    one line of script. Several -e's allowed. Omit [programfile]\n    -Fpattern       split() pattern for autosplit (-a)\n    -Idirectory     specify $LOAD_PATH directory (may be used more than once)\n    -J[java option] pass an option on to the JVM (e.g. -J-Xmx512m)\n                      use --properties to list JRuby properties\n                      run 'java -help' for a list of other Java options\n    -Kkcode         specifies code-set (e.g. -Ku for Unicode\n    -l              enable line ending processing\n    -n              assume 'while gets(); ... end' loop around your script\n    -p              assume loop like -n but print line also like sed\n    -rlibrary       require the library, before executing your script\n    -s              enable some switch parsing for switches after script name\n    -S              look for the script in bin or using PATH environment variable\n    -T[level]       turn on tainting checks\n    -v              print version number, then turn on verbose mode\n    -w              turn warnings on for your script\n    -W[level]       set warning level; 0=silence, 1=medium, 2=verbose (default)\n    -X[option]      enable extended option (omit option to list)\n    --copyright     print the copyright\n    --debug         sets the execution mode most suitable for debugger functionality\n    --jdb           runs JRuby process under JDB\n    --properties    List all configuration Java properties (pass -J-Dproperty=value)\n    --sample        run with profiling using the JVM's sampling profiler\n    --client        use the non-optimizing \"client\" JVM (improves startup; default)\n    --server        use the optimizing \"server\" JVM (improves perf)\n    --manage        enable remote JMX management and monitoring of the VM and JRuby\n    --1.8           specify Ruby 1.8.x compatibility (default)\n    --1.9           specify Ruby 1.9.x compatibility\n    --bytecode      show the JVM bytecode produced by compiling specified code\n    --version       print the version  Usage: jruby [switches] [--] [programfile] [arguments]\n\n==Benchmarking==\n\nThe current popular way to benchmark JRuby performance is to perform a gem installation of Rake. The install process exercises a number of APIs and represents a fairly general-purpose application of Ruby. It's also extremely interpreter-heavy.\n\nAfter getting a build of JRuby, as above, the following steps can be used to benchmark JRuby using Gem and Rake:\n\n*Fetch the current Rake gem from [http://rubyforge.org/frs/?group_id=50 RubyForge]\n*Execute the following command (putting JRUBY_HOME/bin in your path or referencing it directly):\n JRUBY_HOME/bin/gem install <rake gem file>\n*By preceding this command line with the unix \"time\" command you can test end-to-end performance. Of course there are other ways to wire in profiling and performance-monitoring tools that won't be detailed here.\n\nA sample run from a MacBook Pro under Apple's Java 6 JVM is shown below:\n\n Nutters-Computer:~/Documents/workspace/jruby headius$ time bin/gem install rake-0.7.1.gem \n Successfully installed rake, version 0.7.1\n Installing ri documentation for rake-0.7.1...\n Installing RDoc documentation for rake-0.7.1...\n \n real    0m52.596s\n user    0m51.740s\n sys     0m2.146s\n\n==Example code==\n\nBelow is some example code of calling ruby from within java and java from ruby\n\nRuby:  call_java.rb\n\n  require \"java\"\n  \n  include_class \"java.util.TreeSet\"\n  include_class \"com.example.CallMe\"\n  include_class \"com.example.ISpeaker\"\n  \n  puts \"Hello from ruby\"\n  set = TreeSet.new\n  set.add \"foo\"\n  set.add \"Bar\"\n  set.add \"baz\"\n  set.each { |v| puts \"value: #{v}\" }\n  \n  cm = CallMe.new\n  cm.hello\n  $globalCM.hello\n  \n  class CallJava\n    include ISpeaker\n    def initialize\n      super\n      @count = 0\n    end\n  \n    def say(msg)\n      puts \"Ruby saying #{msg}\"\n    end\n    \n    def addOne(from)\n  #    m.synchronize {\n        @count += 1\n        puts \"Now got #@count from #{from}\"\n  #    }\n    end\n  end\n\nJava: ISpeaker.java\n\n    package com.example;\n    \n    public interface ISpeaker {\n        public void say(String msg);\n        \n        public void addOne(String from);\n    }\n\nJava: CallMe.java\n\n    package com.example;\n    \n    public class CallMe {\n    \n        String mName;\n    \n        public CallMe() {\n            this(\"Default\");\n        }\n        \n        public CallMe(String name) {\n            mName = name;\n        }\n        \n        public void hello() {\n            System.out.println(\"Hello from \"+mName);\n        }\n        \n        public static void main(String []args) {\n            System.out.println(\"Called main\");\n        }\n    }\n\nJava: CallRuby.java\n\n    package com.example;\n    \n    import org.apache.bsf.BSFManager;\n    import org.apache.bsf.util.IOUtils;\n    import org.jruby.Ruby;\n    import org.jruby.javasupport.Java;\n    import org.jruby.javasupport.JavaEmbedUtils;\n    import org.jruby.javasupport.JavaUtil;\n    import org.jruby.runtime.Block;\n    import org.jruby.runtime.GlobalVariable;\n    import org.jruby.runtime.builtin.IRubyObject;\n    \n    import java.io.FileReader;\n    import java.io.IOException;\n    \n    /**\n     * Example of how to:\n     * 1. Use java objects in ruby\n     * 2. Subclass/implement java objects in ruby\n     * 3. Get ruby objects for use in java world\n     * 4. Proxy ruby objects for normal use as java objects (interfaces/class)\n     */\n    public class CallRuby {\n    \n        public static void main(String[] args) throws Exception {\n    \n            String dir = \"/dclark/workspace/jrubytest/ruby/\";\n    \n            double[] deltas = new double[3];\n            for (int i = 0; i < 3; i++) {\n                boolean useBSF = (i == 0);\n                long start = System.currentTimeMillis();\n    \n                if (useBSF) {\n                    //--- Initialise ruby\n                    BSFManager.registerScriptingEngine(\"ruby\", \"org.jruby.javasupport.bsf.JRubyEngine\", new String[]{\"rb\"});\n                    BSFManager manager = new BSFManager();\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    manager.declareBean(\"globalCM\", javaCallMe, javaCallMe.getClass());\n    \n                    //--- Load a ruby file\n                    manager.exec(\"ruby\", \"call_java.rb\", -1, -1, getFileContents(dir + \"call_java.rb\"));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    ISpeaker ruby = (ISpeaker) manager.eval(\"ruby\", \"call_java.rb\", -1, -1, expr);\n    \n                    testMultiThreadsCallingRubyObject(ruby);\n    \n                } else {\n    \n                    //--- Initialise ruby\n                    final Ruby runtime = Ruby.getDefaultInstance();\n    \n                    // Need the blank object so can get a nice runtime for the Java.staticMethods calls\n                    runtime.eval(runtime.parse(\"require \\\"java\\\"\\nclass BlankForJva\\nend\\n\", \"BlankForJva.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n                    final IRubyObject blankRuby = runtime.evalScript(\"BlankForJva.new\");\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    IRubyObject globValue = JavaUtil.convertJavaToRuby(runtime, javaCallMe);\n    \n                    // Wrap so that all methods are visible to ruby\n                    globValue = Java.java_to_ruby(blankRuby, globValue, Block.NULL_BLOCK);\n    \n                    GlobalVariable globVar = new GlobalVariable(runtime, \"$globalCM\", globValue);\n                    runtime.defineVariable(globVar);\n    \n                    //--- Load a ruby file\n                    runtime.eval(runtime.parse(getFileContents(dir + \"call_java.rb\"), \"call_java.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    final IRubyObject rawRuby = runtime.evalScript(expr);\n                    ISpeaker ruby;\n                    if (i == 1) {\n                        // Standard wrapper using Java Proxies\n                        ruby = (ISpeaker) JavaEmbedUtils.rubyToJava(runtime, rawRuby, ISpeaker.class);\n                    } else {\n                        // Or manually wrap ruby object so can be used as the interface (can optionally add synchronization as required on methods)\n                        ruby = new ISpeaker() {\n                            public void addOne(String from) {\n                                //                            synchronized (rawRuby) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"addOne\", JavaUtil.convertJavaToRuby(runtime, from));\n                                //                            }\n                            }\n    \n                            public void say(String msg) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"say\", JavaUtil.convertJavaToRuby(runtime, msg));\n                            }\n                        };\n                    }\n                    testMultiThreadsCallingRubyObject(ruby);\n                }\n                long end = System.currentTimeMillis();\n                deltas[i] = (end - start) / 1000.0;\n            }\n    \n            for (int i = 0; i < deltas.length; i++) {\n                System.out.println(\"Took \" + deltas[i] + \" on pass \" + i);\n            }\n        }\n    \n        private static String getFileContents(String filename) throws IOException {\n            FileReader in = new FileReader(filename);\n            return IOUtils.getStringFromReader(in);\n        }\n    \n        public static void testMultiThreadsCallingRubyObject(final ISpeaker ruby) throws InterruptedException {\n            Thread t1 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t1\");\n                    }\n                }\n            });\n            Thread t2 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t2\");\n                    }\n                }\n            });\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            ruby.addOne(\"end\");\n        }\n    }\n\nNote that if you only have simple interface requirements then you can use the second method of proxying the ruby object to include method level synchronization.\n\nNote that BSF calling does not preserve ruby stack traces (add an error to a script and run both ways using the code above).\n\nAlso, note that the times you get from running this example are interesting (on my old Windows box using Java5):\n\n  Took 5.469 on pass 0  // This is the Standard BSF Wrapping\n  Took 1.75 on pass 1   // Using normal Java Proxies\n  Took 1.359 on pass 2  // Rolling your own redirector class to call Ruby\n","created_at":"2009-06-12T19:57:55Z","content_type":"application/vnd.com.kenai.page.revision+json"}