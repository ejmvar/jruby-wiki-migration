{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JRubyCompiler/revisions/6.json","name":"JRubyCompiler","number":6,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JRubyCompiler.json","person":"pfussell","description":"Edited document, added heading and link back to home wiki page and page of reference, Performance Tuning","text":"[[Home|&raquo; JRuby Project Wiki Home Page]]  |  [[PerformanceTuning|&raquo; JRuby Performance Tuning]]\n<h1>JRuby Compiler</h1>\n__TOC__\n\nThe JRuby compiler supports both ahead-of-time (AOT) and just-in-time (JIT) compiling.\n\n==Ahead-Of-Time (AOT) Compilation==\nThe typical way to run the AOT compiler is to run \n jrubyc <script name>\n\nOr, on Microsoft Windows:\n jruby -S jrubyc <script name>\n\nThis command outputs a <tt>.class</tt> file in the current directory with parent directories and package matching where the file lives. So the following command\n jrubyc foo/bar/test.rb \n\nwill output\n foo/bar/test.class\n\nTo run the file produced by the compiler, use the <tt>-cp</tt> (class searchpath) parameter with both the current directory (parent directory for foo/bar/test.class above) and the path to <tt>jruby.jar</tt>, and execute it as you would a normal Java class named foo.bar.test:\n\n java -cp .:/path/to/jruby.jar foo.bar.test\n\n'''Note from [[User:Dhjdhj|Dhjdhj]] 08:17, 6 November 2008 (PST)'''\n\nIf you're getting errors about missing requires, then you need to use the [http://repository.codehaus.org/org/jruby/jruby-complete jruby-complete jar] for running. I do not know why this jar file is not included with the standard distribution.  \n\nAlso, if you're trying to do this from a Microsoft Windows command window (not cygwin), then to compile your code you need to use the command\n\n jruby -S jrubyc foo/bar/test.rb\n\nwhich outputs <tt>test.class</tt> to the <tt>foo\\bar\\</tt> subdirectory of the current directory.\n\n==Just-In-Time (JIT) Compilation==\nIn addition to AOT compiling described above, JRuby supports using the compiler in JIT mode, where it will attempt to compile methods as they're called. After a call threshold is reached, the JIT tries to compile the method body in question, including any blocks it contains. If the compilation succeeds, the compiled version is used from then on. Otherwise, the method is permanently marked \"interpret only\".\n\nThe JIT is enabled by default with a threshold of 50. You can turn it off by using the <tt>-J-Djruby.jit.enabled=false</tt> flag. For example:\n jruby -J-Djruby.jit.enabled=false myscript.rb\n\nFor more information on JIT flags, see [[PerformanceTuning#JIT_Runtime_Properties|JIT Runtime Properties]].\n\n==Performance==\nHere are a few microbenchmarks comparing Ruby, JRuby interpreted, and JRuby compiled (server VM numbers show worst and best numbers):\n\n fib(30) Ruby:                1.67s\n fib(30) JRuby interp (client VM):    3.93s\n fib(30) JRuby interp (server VM):    2.28s to 2.08s\n fib(30) JRuby compiled (client VM):    1.89s to 1.79s\n fib(30) JRuby compiled (server VM):    1.66s to 0.86s\n\n==Tweaking and troubleshooting==\nThere are other interesting properties you can use.\n\n'''Note:''' To see all the JRuby properties, use the <tt>jruby --properties</tt> command:\n\n jruby.compile.mode=OFF|JIT|FORCE (default JIT)\n:Sets compilation to none, JIT, or AOT\n\n ruby.jit.threshold=## (default 50)\n:Sets the threshold for methods to get jitted. (I usually use it to make all methods compile before execution, using threshold=0.)\n\n jruby.jit.logging=true|false (default false)\n:Logs each method as it's compiled, so you can see what kind of coverage you're getting or if the methods you want to JIT are getting JITed.\n\n jruby.jit.logging.verbose=true|false (default false)\n:Logs each method that fails to compile, so you can see if compilation problems are keeping methods from JITing.\n\n jruby.jit.exclude=&lt;class_or_module_name&gt;|&lt;class_or_module_name&gt;#&lt;methodname&gt;|&lt;methodname&gt;\n:Excludes either the class, module, instance_method on a class, instance_method on a module, or a global method name.\n\nAs of late September 2007, the JRuby compiler is considered complete. Any features missing are to be considered bugs. As part of JRuby's test run, the entire Ruby standard library is compiled to Java bytecode.\n\nThere are two known issues with the JRuby compiler at present, which might or might not get fixed:\n\n* Calling a method with a <tt>while false</tt> loop as its parameter will fail to execute\n\n foo(while false; end) # results in an error\n\n* The <tt>retry</tt> keyword is not currently supported outside a <tt>rescue</tt> block, largely because of performance considerations and general confusion around how it's supposed to work. Additionally, no one appears to use <tt>retry</tt> outside <tt>rescue</tt>.\n\n==JRuby Compiler Design==\nJRuby compiles Ruby code to Java bytecode. Once complete, there's no interpretation done, except for <tt>eval</tt> calls. Evaluated code never gets compiled; however, if the <tt>eval</tt> defines a method that's called enough, it will also eventually get JIT compiled to bytecode. JRuby is a mixed-mode engine.\n\n===Output Is a Class File===\nGiven a single input <tt>.rb</tt> file, JRuby produces a single output <tt>.class</tt> file. This was a key design goal for the compiler. Other languages (including Groovy) and other Ruby implementations (including XRuby) produce numerous classes from an input file, in some cases, dozens and dozens of classes if the input file is very large and complex. JRuby produces one <tt>.class</tt> file.\n\n===Multiple Passes Over AST===\nJRuby compiles from the same AST as it interprets from. There is a first pass over the AST before compilation to determine certain runtime characteristics:\n\n* Does a method have closures in it?\n* Does a method have calls to eval or other scope and frame-aware methods?\n* Does a method have class definitions in it?\n* Does a method define other methods?\n* .... and so on\n\nBased on this pass, the compiler determines scoping characteristics of all code in the method, selectively choosing pure heap-based variables or pure stack-based variables. Only methods and leaf closures without <tt>eval</tt>, <tt>closures</tt>, and so on, can use normal stack-based local variables. Performance is significantly faster with stack variables.\n\n===Methods in Output Class File===\nThe resulting class file from JRuby contains at a minimum the following methods to start:\n\n* A normal <tt>main()</tt> method for running from the command line. (It grabs a default JRuby runtime and launches itself.)\n* A <tt>load()</tt> instance method that represents a normal top-level loading of the script into a runtime. This performs pre and post script setup and teardown.\n* A <tt>run()</tt> instance method that represents a bare execution of the script's contents. This is used by the JIT, where setup and teardown is handled outside the JITed code on a method-by-method basis\n* A <tt>__file__()</tt> method that represents the body of the script. This is where script execution eventually starts.\n\nThen, depending on the contents of the file, additional methods are added:\n\n* Normal method definition bodies become Java methods.\n* Class and module bodies become Java methods.\n* Closure bodies become Java methods.\n* Rescue and ensure bodies become synthetic methods.\n* If the normal top-level script method is too long, it's split every 500 top-level syntactic elements and chained. (We did run into one large flat file that broke the method size limit.) We do not yet perform chaining on normal method bodies because we have not encountered any that are too large.\n\n===Direct Invocation, Binding Into the MOP, and Reflection===\nOnly class bodies, <tt>rescue/ensure</tt> bodies, and chained top-level script methods get directly invoked during script execution. The others are bound into the MetaObject Protocol (MOP) at runtime.\n\nBinding occurs in one of two ways:\n* By generating a small stub class that implements <tt>DynamicMethod</tt> and invokes the target method on the target script directly\n* By doing the same with reflection\n\nIn our testing, generating stub ''invoker'' classes has always been faster than reflection, especially on older JVMs. For the time being, that's the preferred way to bind methods, but I'm going to get reflection-based binding working again for limited/restricted environments like applets. With reflection-based binding and pre-compiled Ruby code with no <tt>evals</tt>, JIT compilation could be completely turned off and no classes would ever be generated in memory by JRuby.\n\n===Walkthrough of a Simple Script===\nHere's a walkthrough of a simple script:\n\n # we enter into the script body in the __file__ method\n # require would first look for .rb files, then try to load .class\n require 'foo'\n \n # normal code in the method body\n puts 'here we go'\n \n # upon encountering a method def, a new method is started in the class\n def bar\n   # this is a simple method body, and would use stack-based vars\n   puts 'hello'\n end\n # once the method has been compiled, binding code is added to __file__\n \n # class definitions become methods as well, building the class\n class MyClass\n   # this is code in the body of the class\n   puts 'here'\n \n   # a method in the class is compiled like any other method body\n   def something(a, b = 2, *c, &block)\n     # this method has all four param types:\n     # normal, optional, \"rest\" or varargs, and block argument\n     # the compiler generates code to assign these from an incoming\n     # IRubyObject[]\n \n     # this method has a closure, so it would use heap-based vars\n     # ... but the closure would use stack vars, since it's a simple leaf\n     1.times { puts 'in closure' }\n   end\n   # method is completed, bound into the class we're building\n end\n # end of class definition; __file__ code invokes the class body directly \n \n # any begin block or method body with a rescue/ensure attached will\n # be compiled as a synthetic method. This also necessarily means that\n # method bodies containing rescue/ensure must be heap-based.\n begin\n   puts 'rescue me'\n rescue\n   puts 'rescued!'\n ensure\n   puts 'ensured!'\n end\n\n===Sample Run of the JRuby Compiler===\n\n ~/NetBeansProjects/jruby $ jruby sample_script.rb\n here we go\n here\n rescue me\n ensured!\n \n ~/NetBeansProjects/jruby $ jrubyc sample_script.rb\n Compiling file \"sample_script.rb\" as class \"sample_script\"\n \n ~/NetBeansProjects/jruby $ ls -l sample_script.*\n -rw-r--r--   1 headius  headius  8396 Oct  4 09:38 sample_script.class\n -rw-r--r--   1 headius  headius  1449 Oct  4 09:38 sample_script.rb\n \n ~/NetBeansProjects/jruby $ export\n CLASSPATH=lib/jruby.jar:lib/asm-3.0.jar:lib/jna.jar:.\n \n ~/NetBeansProjects/jruby $ java sample_script\n here we go\n here\n rescue me\n ensured!\n","created_at":"2009-06-23T23:48:11Z","content_type":"application/vnd.com.kenai.page.revision+json"}