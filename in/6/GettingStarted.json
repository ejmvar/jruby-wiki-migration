{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/GettingStarted/revisions/6.json","name":"GettingStarted","number":6,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/GettingStarted.json","person":"remogatto","description":"fix git repository reference","text":"==QuickStart with JRuby==\n\nThe easiest way to get started with JRuby is to use your operating system's package manager. If you're on Windows, or if your package manager doesn't include JRuby you'll need to extract it yourself. Jump to [[#Installing_JRuby|Installing JRuby]] for the three-step process.\n\n; MacPorts : sudo port install jruby\n; Emerge : emerge jruby\n; apt-get : apt-get install jruby\n; yum : yum install jruby\n\nOnce you're done, jump down to [[#Did_it_work|Did it work?]] to continue.\n\n==Installing JRuby==\n\nGetting up and running with JRuby is very easy:\n\n# [http://dist.codehaus.org/jruby/1.2.0/jruby-bin-1.2.0.zip Download JRuby]\n# Extract JRuby into a directory.\n# Add that directory's bin subdirectory to the '''end''' of your path.\n#* On *Nix (OSX, Linux, BSD), that will be '''$PATH'''\n#* On Windows, that will be '''%PATH%'''\n# (On windows, make sure that your '''JAVA_HOME''' environment variable points to your Java installation)\n\n====Example====\nOnce you've downloaded or built a JRuby install and it is located in the directory:\n /opt/jruby\nyou'll need to add /opt/jruby/bin to the end of your $PATH environmental variable.\n\nOn Mac OS X and Linux:\n  export PATH=$PATH:/opt/local/bin\n\n==Alternatives==\nInstead of downloading the latest release, you can build JRuby from source. See the instructions [[#Downloading_Source_and_Building_Yourself]] later on this page for more details.\n\n==Did it work==\nTo test whether it installed correctly, run:\n  jruby -v\n\nIf it installed correctly, JRuby will return the current version.\n\n==How do I run rake, gem, etc.==\nThe recommended way to run these commands (known as ''system-level executable commands'') in JRuby is to '''always''' use ''jruby -S''\n\n  jruby -S gem list --local\n  jruby -S gem install rails mongrel jdbc-mysql activerecord-jdbcmysql-adapter\n  jruby -S rails blog\n  cd blog\n  jruby -S rake -T\n  jruby -S rake db:migrate\n\nThe '''-S''' parameter tells JRuby to use '''its''' version of the installed binary.\n\n==How do I run a Ruby program?==\n\nTo run any other ruby program using JRuby, run it using the '''jruby''' command:\n\n  jruby script/server\n  jruby my_ruby_script.rb\n\n== jirb: Ruby Interactive Console ==\nOne of the few (perhaps only) standard Ruby utility that has a different name in JRuby than in C Ruby is the command for the interactive Ruby console: <tt>'''jirb'''</tt>. In C Ruby this utility is simply called <tt>irb</tt>.\n\nTo enable tab completion within jirb:\n  require 'irb/completion'\n\n==Installing and using Gems in JRuby==\n\nThe RubyGems can be easily installed with JRuby as follows:\n jruby -S gem install rails mongrel jdbc-mysql activerecord-jdbcmysql-adapter\n\nMany Gems will work fine in JRuby, however some Gems build native C libraries as part of their install process. These Gems will not work in JRuby unless the Gem has also provided a Java equivalent to the native library. \n\nMongrel and Hpricot are two examples of Gems that build their native library in a platform independent manner. Each of them specify a parsing library using the Ragel language and a Ragel program can be automatically converted into either C or Java as part of the compile process.\n\nAlso, keep in mind that installing gems from behind a firewall will require setting the HTTP_PROXY (e.g.  <nowiki>export http_proxy=http://${http-proxy-host}:${http-proxy-port}/</nowiki> or <nowiki>export http_proxy=http://{your_user_id}:{your_password}@${http-proxy-host}:${http-proxy-port}/</nowiki> if it's authenticated)\n \nSee also [[Troubleshooting]].\n\n==JRuby Command Parameters==\n\n  $ jruby --help\n  Usage: jruby [switches] [--] [programfile] [arguments]\n    -0[octal]       specify record separator (, if no argument)\n    -a              autosplit mode with -n or -p (splits $_ into $F)\n    -b              benchmark mode, times the script execution\n    -c              check syntax only\n    -Cdirectory     cd to directory, before executing your script\n    -d              set debugging flags (set $DEBUG to true)\n    -e 'command'    one line of script. Several -e's allowed. Omit [programfile]\n    -Fpattern       split() pattern for autosplit (-a)\n    -Idirectory     specify $LOAD_PATH directory (may be used more than once)\n    -J[java option] pass an option on to the JVM (e.g. -J-Xmx512m)\n                      use --properties to list JRuby properties\n                      run 'java -help' for a list of other Java options\n    -Kkcode         specifies code-set (e.g. -Ku for Unicode\n    -l              enable line ending processing\n    -n              assume 'while gets(); ... end' loop around your script\n    -p              assume loop like -n but print line also like sed\n    -rlibrary       require the library, before executing your script\n    -s              enable some switch parsing for switches after script name\n    -S              look for the script in bin or using PATH environment variable\n    -T[level]       turn on tainting checks\n    -v              print version number, then turn on verbose mode\n    -w              turn warnings on for your script\n    -W[level]       set warning level; 0=silence, 1=medium, 2=verbose (default)\n    -X[option]      enable extended option (omit option to list)\n    --copyright     print the copyright\n    --debug         sets the execution mode most suitable for debugger functionality\n    --jdb           runs JRuby process under JDB\n    --properties    List all configuration Java properties (pass -J-Dproperty=value)\n    --sample        run with profiling using the JVM's sampling profiler\n    --client        use the non-optimizing \"client\" JVM (improves startup; default)\n    --server        use the optimizing \"server\" JVM (improves perf)\n    --manage        enable remote JMX management and monitoring of the VM and JRuby\n    --1.8           specify Ruby 1.8.x compatibility (default)\n    --1.9           specify Ruby 1.9.x compatibility\n    --bytecode      show the JVM bytecode produced by compiling specified code\n    --version       print the version  Usage: jruby [switches] [--] [programfile] [arguments]\n\n==Downloading Source and Building Yourself==\n\nThe JRuby source code is available in a git repository. Retrieve the trunk version of the JRuby source and build JRuby using the following shell commands ('''Note:''' Ant 1.7 is required to build JRuby version greater than 1.1):\n git clone git://kenai.com/jruby~main jruby\n cd jruby\n ant\n\nCreate an up-to-date version of <tt>jruby-complete.jar</tt> with this ant task: \n ant jar-complete\n\nGenerate an up-to-date set of the JavaDoc for JRuby located here: <tt>docs/api/index.html</tt>:\n ant create-apidocs\n\nDelete any build and compile artifacts:\n  ant clean\n\nRun the JRuby tests:\n  ant test\n\nRetrieve revision 6130 of the JRuby source:\n svn co -r 6130 http://svn.codehaus.org/jruby/trunk/jruby jruby\n\nYou can easily automate all of this and more into a single script, see: http://pastie.caboo.se/165048.\n\n==Benchmarking==\n\nThe current popular way to benchmark JRuby performance is to perform a gem installation of Rake. The install process exercises a number of APIs and represents a fairly general-purpose application of Ruby. It's also extremely interpreter-heavy.\n\nAfter getting a build of JRuby, as above, the following steps can be used to benchmark JRuby using Gem and Rake:\n\n*Fetch the current Rake gem from [http://rubyforge.org/frs/?group_id=50 RubyForge]\n*Execute the following command (putting JRUBY_HOME/bin in your path or referencing it directly):\n JRUBY_HOME/bin/gem install <rake gem file>\n*By preceding this command line with the unix \"time\" command you can test end-to-end performance. Of course there are other ways to wire in profiling and performance-monitoring tools that won't be detailed here.\n\nA sample run from a MacBook Pro under Apple's Java 6 JVM is shown below:\n\n Nutters-Computer:~/Documents/workspace/jruby headius$ time bin/gem install rake-0.7.1.gem \n Successfully installed rake, version 0.7.1\n Installing ri documentation for rake-0.7.1...\n Installing RDoc documentation for rake-0.7.1...\n \n real    0m52.596s\n user    0m51.740s\n sys     0m2.146s\n\n==Example code==\n\nBelow is some example code of calling ruby from within java and java from ruby\n\nRuby:  call_java.rb\n\n  require \"java\"\n  \n  include_class \"java.util.TreeSet\"\n  include_class \"com.example.CallMe\"\n  include_class \"com.example.ISpeaker\"\n  \n  puts \"Hello from ruby\"\n  set = TreeSet.new\n  set.add \"foo\"\n  set.add \"Bar\"\n  set.add \"baz\"\n  set.each { |v| puts \"value: #{v}\" }\n  \n  cm = CallMe.new\n  cm.hello\n  $globalCM.hello\n  \n  class CallJava\n    include ISpeaker\n    def initialize\n      super\n      @count = 0\n    end\n  \n    def say(msg)\n      puts \"Ruby saying #{msg}\"\n    end\n    \n    def addOne(from)\n  #    m.synchronize {\n        @count += 1\n        puts \"Now got #@count from #{from}\"\n  #    }\n    end\n  end\n\nJava: ISpeaker.java\n\n    package com.example;\n    \n    public interface ISpeaker {\n        public void say(String msg);\n        \n        public void addOne(String from);\n    }\n\nJava: CallMe.java\n\n    package com.example;\n    \n    public class CallMe {\n    \n        String mName;\n    \n        public CallMe() {\n            this(\"Default\");\n        }\n        \n        public CallMe(String name) {\n            mName = name;\n        }\n        \n        public void hello() {\n            System.out.println(\"Hello from \"+mName);\n        }\n        \n        public static void main(String []args) {\n            System.out.println(\"Called main\");\n        }\n    }\n\nJava: CallRuby.java\n\n    package com.example;\n    \n    import org.apache.bsf.BSFManager;\n    import org.apache.bsf.util.IOUtils;\n    import org.jruby.Ruby;\n    import org.jruby.javasupport.Java;\n    import org.jruby.javasupport.JavaEmbedUtils;\n    import org.jruby.javasupport.JavaUtil;\n    import org.jruby.runtime.Block;\n    import org.jruby.runtime.GlobalVariable;\n    import org.jruby.runtime.builtin.IRubyObject;\n    \n    import java.io.FileReader;\n    import java.io.IOException;\n    \n    /**\n     * Example of how to:\n     * 1. Use java objects in ruby\n     * 2. Subclass/implement java objects in ruby\n     * 3. Get ruby objects for use in java world\n     * 4. Proxy ruby objects for normal use as java objects (interfaces/class)\n     */\n    public class CallRuby {\n    \n        public static void main(String[] args) throws Exception {\n    \n            String dir = \"/dclark/workspace/jrubytest/ruby/\";\n    \n            double[] deltas = new double[3];\n            for (int i = 0; i < 3; i++) {\n                boolean useBSF = (i == 0);\n                long start = System.currentTimeMillis();\n    \n                if (useBSF) {\n                    //--- Initialise ruby\n                    BSFManager.registerScriptingEngine(\"ruby\", \"org.jruby.javasupport.bsf.JRubyEngine\", new String[]{\"rb\"});\n                    BSFManager manager = new BSFManager();\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    manager.declareBean(\"globalCM\", javaCallMe, javaCallMe.getClass());\n    \n                    //--- Load a ruby file\n                    manager.exec(\"ruby\", \"call_java.rb\", -1, -1, getFileContents(dir + \"call_java.rb\"));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    ISpeaker ruby = (ISpeaker) manager.eval(\"ruby\", \"call_java.rb\", -1, -1, expr);\n    \n                    testMultiThreadsCallingRubyObject(ruby);\n    \n                } else {\n    \n                    //--- Initialise ruby\n                    final Ruby runtime = Ruby.getDefaultInstance();\n    \n                    // Need the blank object so can get a nice runtime for the Java.staticMethods calls\n                    runtime.eval(runtime.parse(\"require \\\"java\\\"\\nclass BlankForJva\\nend\\n\", \"BlankForJva.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n                    final IRubyObject blankRuby = runtime.evalScript(\"BlankForJva.new\");\n    \n                    //--- Define a global variable\n                    CallMe javaCallMe = new CallMe(\"globalCallMeInJava\");\n                    IRubyObject globValue = JavaUtil.convertJavaToRuby(runtime, javaCallMe);\n    \n                    // Wrap so that all methods are visible to ruby\n                    globValue = Java.java_to_ruby(blankRuby, globValue, Block.NULL_BLOCK);\n    \n                    GlobalVariable globVar = new GlobalVariable(runtime, \"$globalCM\", globValue);\n                    runtime.defineVariable(globVar);\n    \n                    //--- Load a ruby file\n                    runtime.eval(runtime.parse(getFileContents(dir + \"call_java.rb\"), \"call_java.rb\", runtime.getCurrentContext().getCurrentScope(), 0));\n    \n                    //--- Make a new ruby object\n                    String expr = \"CallJava.new\";\n                    final IRubyObject rawRuby = runtime.evalScript(expr);\n                    ISpeaker ruby;\n                    if (i == 1) {\n                        // Standard wrapper using Java Proxies\n                        ruby = (ISpeaker) JavaEmbedUtils.rubyToJava(runtime, rawRuby, ISpeaker.class);\n                    } else {\n                        // Or manually wrap ruby object so can be used as the interface (can optionally add synchronization as required on methods)\n                        ruby = new ISpeaker() {\n                            public void addOne(String from) {\n                                //                            synchronized (rawRuby) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"addOne\", JavaUtil.convertJavaToRuby(runtime, from));\n                                //                            }\n                            }\n    \n                            public void say(String msg) {\n                                rawRuby.callMethod(runtime.getCurrentContext(), \"say\", JavaUtil.convertJavaToRuby(runtime, msg));\n                            }\n                        };\n                    }\n                    testMultiThreadsCallingRubyObject(ruby);\n                }\n                long end = System.currentTimeMillis();\n                deltas[i] = (end - start) / 1000.0;\n            }\n    \n            for (int i = 0; i < deltas.length; i++) {\n                System.out.println(\"Took \" + deltas[i] + \" on pass \" + i);\n            }\n        }\n    \n        private static String getFileContents(String filename) throws IOException {\n            FileReader in = new FileReader(filename);\n            return IOUtils.getStringFromReader(in);\n        }\n    \n        public static void testMultiThreadsCallingRubyObject(final ISpeaker ruby) throws InterruptedException {\n            Thread t1 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t1\");\n                    }\n                }\n            });\n            Thread t2 = new Thread(new Runnable() {\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        ruby.addOne(\"t2\");\n                    }\n                }\n            });\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            ruby.addOne(\"end\");\n        }\n    }\n\nNote that if you only have simple interface requirements then you can use the second method of proxying the ruby object to include method level synchronization.\n\nNote that BSF calling does not preserve ruby stack traces (add an error to a script and run both ways using the code above).\n\nAlso, note that the times you get from running this example are interesting (on my old Windows box using Java5):\n\n  Took 5.469 on pass 0  // This is the Standard BSF Wrapping\n  Took 1.75 on pass 1   // Using normal Java Proxies\n  Took 1.359 on pass 2  // Rolling your own redirector class to call Ruby\n","created_at":"2009-05-10T14:19:21Z","content_type":"application/vnd.com.kenai.page.revision+json"}