{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/DirectJRubyEmbedding/revisions/3.json","name":"DirectJRubyEmbedding","number":3,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/DirectJRubyEmbedding.json","person":"dkoontz","description":"Added section on passing params to a Ruby object's initialize","text":"__TOC__\n\n==Direct Embedding==\n\nJRuby can also be embedded directly using JRuby's own APIs. The interfaces in JavaEmbedUtils are meant to be long-lasting API's for raw embedding. This is generally only recommended for people embedding into other scripting engines and frameworks or for those who need a \"bare metal\" approach and are willing to keep up with continuing JRuby API changes. It is strongly recommended for most embedders to use BSF or javax.scripting APIs to embed JRuby. See [[Java Integration]].\n\n===Instantiating the JRuby interpreter===\nThe most direct method of running JRuby in Java is as follows (works for JRuby 1.0.3+ and JRuby 1.1):\n\n<pre>\nimport org.jruby.Ruby;\nimport org.jruby.RubyRuntimeAdapter;\nimport org.jruby.javasupport.JavaEmbedUtils;  \n{...}\n// Create runtime instance\nRuby runtime = JavaEmbedUtils.initialize(new ArrayList());\nRubyRuntimeAdapter evaler = JavaEmbedUtils.newRuntimeAdapter();\n\n{...}\nevaler.eval(runtime, \"puts 1+2\");\n{...}\n\n// Shutdown and terminate instance\nJavaEmbedUtils.terminate(runtime);\n</pre>\n\n===Subclassing a Java class===\n<pre>\n/*\nThis is run using\njava -cp .:/path/to/jruby.jar  RubyFromJava\n\n*/\n\nimport org.jruby.*;\n\npublic class RubyFromJava {\n\tpublic String fooString() {\n\t\treturn \"foo\";\n\t}\n\t\n\tpublic static void main(String[] ARGV) {\n\t\tSystem.out.println(\"Started\");\n\t\tboring.SuperTest sTest = new boring.SuperTest();\n\t\t\n\t\tSystem.out.println(\"boring: \" + sTest.fooString() + \"\\n\");\n\t\t\n\t\tRuby runtime = Ruby.getDefaultInstance();\n\n\t\t/* This script subclasses the Object class.\n\t\tIt is then instantiated and the foobarString method is called. */\n\t\t\n\t\tString script = \n\t\t\t\"require 'java'\\n\" +\n\t\t\t\"class RSubclass1 < java.lang.Object\\n\" + // subclassing java.* is magic\n\t\t\t\"\tdef foobarString\\n\" +\n\t\t\t\"\t\treturn @returnString = toString() + 'BAR'\\n\" +\n\t\t\t\"\tend\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"rsubclass = RSubclass1.new\\n\" +\n\t\t\t\"puts(rsubclass.foobarString())\\n\" +\n\t\t\t\"end\";\n\t\truntime.evalScript(script);\n\n\t\tSystem.out.println(\"-----------------\\n\");\n\n\t\t/* This script subclasses the RubyFromJava class.\n\t\tIt is then instantiated and the foobarString method is called. */\n\n\t\tscript = \n\t\t\t\"require 'java'\\n\" +\n\t\t\t\"class RSubclass2 < Java::RubyFromJava\\n\" + // subclassing non java.* requires you prefix the class with Java::\n\t\t\t\"\tdef foobarString\\n\" +\n\t\t\t\"\t\treturn @returnString = fooString() + 'BAR'\\n\" +\n\t\t\t\"\tend\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"rsubclass = RSubclass2.new\\n\" +\n\t\t\t\"puts(rsubclass.foobarString())\\n\" +\n\t\t\t\"end\";\n\t\ttry {\n\t\t\truntime.evalScript(script);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(e.toString());\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n</pre>\n\n\n===Using a Ruby subclass by casting it to its Java superclass -- from Java!===\n<pre>\n/*\nThis is run using\njava -cp .:/path/to/jruby.jar  RubyFromJava\n\n*/\n\nimport org.jruby.*;\n\npublic class RubyFromJava {\n\tstatic RubyFromJava globalRFJ;\n\t\n\tpublic String fooString() {\n\t\treturn \"foo\";\n\t}\n\t\n\tpublic static void main(String[] ARGV) {\n\t\tSystem.out.println(\"Started\");\n\t\tboring.SuperTest sTest = new boring.SuperTest();\n\t\t\n\t\tSystem.out.println(\"boring: \" + sTest.fooString() + \"\\n\");\n\t\t\n\t\tRuby runtime = Ruby.getDefaultInstance();\n\n\t\tString script = \n\t\t\t\"require 'java'\\n\" +\n\t\t\t\"class RSubclass < Java::RubyFromJava\\n\" + // subclassing non java.* requires you prefix the class with Java::\n\t\t\t\"\tdef fooString\\n\" +\n\t\t\t\"\t\treturn super + 'BAR!'\\n\" +\n\t\t\t\"\tend\\n\" +\n\t\t\t\"end\";\n\t\ttry {\n\t\t\truntime.evalScript(script);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(e.toString());\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tObject rfj = runtime.evalScript(\"RSubclass.new()\");\n\t\trfj = org.jruby.javasupport.JavaEmbedUtils.rubyToJava(runtime, (org.jruby.runtime.builtin.IRubyObject) rfj, RubyFromJava.class);\n\t\t\n\t\tSystem.out.println(\"Local: \" + ((RubyFromJava) rfj).fooString() + \"\\n\");\n\t}\n}\n</pre>\n\n----\n\n'''Summary - how to do this''' <br/>\n1. Write a Java class X (here in example RubyFromJava.java) which should be subclassed into a Ruby class Y. Let be fooString() be a method which you would like to overwrite in Ruby. This method will be called directly from Java, yet execute Ruby code.\n\n2. Get Ruby runtime instance via\n<pre>\n   Ruby runtime = Ruby.getDefaultInstance();\n</pre>\n\n3. Parse your script with Ruby class Y which overwrites fooString(). Assuming that the script is contained in the String \"script\", you do this via\n<pre>\n   try {\n\truntime.evalScript(script);\n   } catch (Exception e) {e.printStackTrace();}\n</pre>\n\n4. Intantiate Ruby class Y and cast (?) it to Java class X via\n<pre>\n   Object y = runtime.evalScript(\"Y.new()\");\n   y = org.jruby.javasupport.JavaEmbedUtils.rubyToJava(runtime, \n      (org.jruby.runtime.builtin.IRubyObject) y, X.class);\n</pre>\n\n5. Now call the method fooString() of the object y - Ruby code is executed!\n<pre>\n   ((X) y).fooString();\n</pre>\n\n'''Remark 1''': \n\nThe overwritten method can also take parameters (at least Java objects, not sure about Ruby objects). So fooString() can be changed into:\n<pre>\n   public String fooString(String myArg) {\n\treturn \"foo \" + myArg;\n   }\n</pre>\nand the Ruby overwriting method then might look like this:\n<pre>\n   def fooString (myArg)\n\treturn 'BAR!' + myArg\n   end\n</pre>\nYou call then the method as:\n<pre>\n   ((X) y).fooString(\"Argument\");\n</pre>\n'''Remark 2''': \n\nBe aware that the Ruby object y has been created from \"scratch\" and is not initialized. Obviously it is not possible to inherit/copy field values from a Java object x of type X at initialization. You can only access the values of x on Ruby side by passing x to y as a parameter in some call from Java (and then possibly saving as Ruby instance variable etc.) - just like any other Java object. This makes switching between Java and Ruby implementations in a Java framework a bit harder.\n\n=== Passing Java parameters to a Ruby object's new method ===\n\n<pre>\nIRubyObject rubyClass = evaler.eval(runtime, \"MyRubyClass\");\nObject[] parameters = {javaObject, otherJavaObject};\nJavaEmbedUtils.invokeMethod(runtime, rubyClass \"new\", parameters, IRubyObject.class);\n</pre>\n\nIf your Ruby subclass is extending or implementing a Java type, you can set the return type parameter and cast the return value of invokeMethod to the appropriate type.\n\n<pre>\nIRubyObject rubyClass = evaler.eval(runtime, \"MyRubyClass\");\nObject[] parameters = {javaObject, otherJavaObject};\nMyJavaType rubyObject = (MyJavaType)JavaEmbedUtils.invokeMethod(runtime, rubyClass \"new\", parameters, MyJavaType.class);\n</pre>\n\n\n===Ruby code in your classpath, Mixed with java===\nFor those who don't want BSF, and want to have lots of their application code in ruby files on their classpath, the following very simple utility can be useful (feel free to re-use as is):\n\n<pre>\npackage ruby.utils;\n\nimport java.util.ArrayList;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyRuntimeAdapter;\nimport org.jruby.javasupport.JavaEmbedUtils;\nimport org.jruby.runtime.builtin.IRubyObject;\n\n/**\n * This utility is a simple way to keep most of your code in ruby, \n * and must pass across a \"root\" object from java into a \"root\" object\n * on the ruby side (calling a single argument method you specify - the root ruby object is created for you).\n * Ruby code can live on the the classpath, next to your java.\n * This doesn't require BSF, or any mandatory dependencies other then jruby.jar.\n * \n * @author <a href=\"mailto:michael.neale@gmail.com\">Michael Neale</a> \n */\npublic class RubyLauncher {\n\n    /** this is the root object - to be used over and over */\n    private IRubyObject rootRubyObject;\n    private Ruby runtime;\n\n    /**\n     * \n     * @param initialRequire The name of the .rb file that is your starting point (on your claspath).\n     * @param rootRubyClass The name of the ruby class in the above .rb file, must have no-arg constructor (a new instance will be created).\n     * @param rootMethod The name of the method to call in the above class when \"call\" is called.\n     */\n    public RubyLauncher(String initialRequire, String rootRubyClass, String rootMethod) {\n        \n        String bootstrap = \n            \"require \\\"\" + initialRequire +  \"\\\"\\n\"+\n            \"class Bootstrap \\n\" +\n            \"   def execute root_object  \\n\" +          \n            \"       \" + rootRubyClass + \".new.\" + rootMethod + \"(root_object) \\n\" +\n            \"   end    \\n\" +      \n            \"end \\n\" +\n            \"Bootstrap.new\";\n\n        // This list holds the directories where the Ruby scripts can be found; unless you have complete \n        // control how jruby is launched, use absolute paths\n        List<String> loadPaths = new ArrayList<String>();\n\tloadPaths.add(\".\");\n        \n        runtime = JavaEmbedUtils.initialize( loadPaths );\n        rootRubyObject = JavaEmbedUtils.newRuntimeAdapter().eval( runtime, bootstrap );\n    }\n    \n    /**\n     * This can be called over and over on the one instance.\n     * \n     * Pass your root java object to the root ruby object (which was created in the constructor, with the specified method). \n     * If you want to get data out, best bet is to make the root object(s) wrappers for in/out objects.\n     */\n    public void call(Object obj) {\n        JavaEmbedUtils.invokeMethod( runtime, rootRubyObject, \"execute\", new Object[] {obj}, null );\n    }\n    \n    /**\n      * Use this method when embedding ruby files within a jar. They won't be found on the classpath or LOAD_PATH\n      * unless added relative to the location of the jar.\n      *\n      * e.g. jar structure:  /com/example/rubyfiles/my_class.rb\n      * loadPaths.add(getPathToJar(\"/com/example/rubyfiles/\");\n      *\n      * @param jar_internal_path Absolute path to your ruby files inside the jar file\n      * @return String Path URL added to JRuby's LOAD_PATH\n      */\n    private String getPathToJar(String jar_internal_path)\n    {\n        java.net.URL url =  RubyLauncher.class.getResource(jar_internal_path);\n        return url.getPath();\n    }\n}\n</pre>\n\nTo use this is simple, you create a \"root\" ruby object in a .rb file on your classpath, and pass the name/path of that file into the constructor (as well as the initial method to pass the root java object into).\nNote that you can require code that lives elsewhere on your classpath, just as if it is on the filesystem.\n\nFor example:\n<pre>\n  Map<String, Object> root = new HashMap<String, Object>();\n  root.put(\"name\", \"david\");\n\n  RubyLauncher launcher = new RubyLauncher(\"c:/ruby/myscripts/ruby_root.rb\", \"RubyRoot\", \"start\");\n  launcher.call(root);\n</pre>\n\nNOTE: I was unable to get the RubyLauncher to find the Ruby script on my classpath. So I hardcoded the path.\n\n\"RubyRoot\" is the name of a ruby class in ruby_root.rb, and \"start\" is the name of a method that will take the \"nae\" object when \"call\" is invoked. Note that the initial Ruby script can <i>require</i> other .rb files from the classpath (just use the path, like you would on the filesystem) relative to where the \"ruby_root.rb\" file is.\n\n<pre>\nclass RubyRoot\n  \n  def start( root )\n    puts root.toString\n  end\n  \nend\n</pre>\n\nEasy ! And no extra dependencies. This way you can just have minimal java bootstrap code, fire up the RubyLauncher once, and away you go.\n","created_at":"2009-04-08T17:56:16Z","content_type":"application/vnd.com.kenai.page.revision+json"}