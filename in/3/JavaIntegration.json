{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JavaIntegration/revisions/3.json","name":"JavaIntegration","number":3,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/JavaIntegration.json","person":"headius","description":"updating from wiki.jruby.org","text":"__TOC__\n\n==Using the JRuby Interpreter from Java==\n\n===Java 6 (using JSR 223: Scripting) ===\n\nJava integration with Java 6 will be using the standard scripting API (JSR223).  A JRuby scripting engine already exists and is located at https://scripting.dev.java.net/ Download and unzip the collection\nof jars from the documents and files section of the site (jsr223-engines.tar.gz or jsr223-engines.zip).  Look in the uncompressed files for the jruby/build/jruby-engine.jar file.  Add this file to your classpath\nand then use the code below to access the engine.  If you're using JRuby 1.1RC3 and 1.1.x on Java 6, use [https://scripting.dev.java.net/servlets/ProjectDocumentList?folderID=8848&expandFolder=8848&folderID=0 version 1.1.2 or later of the JRuby engine].\n\n<pre>\nimport javax.script.ScriptContext;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n{...}\nScriptEngineManager m = new ScriptEngineManager();\nScriptEngine rubyEngine = m.getEngineByName(\"jruby\");\nScriptContext context = rubyEngine.getContext();\n\ncontext.setAttribute(\"label\", new Integer(4), ScriptContext.ENGINE_SCOPE);\n\ntry{\n    rubyEngine.eval(\"puts 2 + $label\", context);\n} catch (ScriptException e) {\n    e.printStackTrace();\n}\n</pre>\n\nScriptEngine.eval also takes a java.io.Reader object, which allows you to get load scripts from Files or other resource streams very simply, through the same interface.  The context parameter is optional.\n\nIf you want to use scripting API on Java 5, use version 1.1.3 or later of the JRuby engine. Plus download sjp-1_0-fr-ri.zip from http://www.jcp.org/en/jsr/detail?id=223, then, unzip it and add script-api.jar to your classpath. Java 5 users might be better to use com.sun.script.jruby.JRubyScriptEngineManager instead of javax.script.ScriptEngineManager to avoid version mismatch error. However, if you are sure that you don't have any other script engines' archives compiled on JDK 1.6, you can use javax.script.ScriptEngingManager to get engine's instance.\n \nOtherwise, you can use the Apache Bean Scripting Framework if you don't have the luxury of using Java 6.\n\nWhen running the compiled code, be sure to use a java invocation similar to the following:\n\n<pre>\njava -cp .:scripts:bsf.jar:jruby.jar:jruby-engine.jar -Djruby.home=/path/to/jruby/home  my.class.ScriptRunner\n</pre>\n\nThe -Djruby.home part is necessary or the system ruby libraries won't be found.\n\nSee [http://wiki.jruby.org/wiki/Walkthroughs_and_Tutorials#JSR_223_scripting Walkthroughs and Tutorials: JSR 223 scripting] for more information.\n\n===Embedding with Bean Scripting Framework (BSF) ===\n\nThe [[Bean Scripting Framework]], when used with JRuby, will allow you to conveniently to pass your own Java objects to your JRuby script. You can then use these objects in JRuby, and changes will affect your Java program directly. To run a JRuby script using BSF, you must first copy the <code>BSF.jar</code> file into your JAVA_HOME/lib/ext/ folder. Then, try the following:\n<pre>\nimport org.jruby.Ruby.*;\nimport org.jruby.*;\nimport org.jruby.javasupport.bsf.*;\nimport org.apache.bsf.BSFException;\nimport org.apache.bsf.BSFManager;\n{...}\nJLabel mylabel = new JLabel();\nBSFManager.registerScriptingEngine(\"ruby\", \n                                   \"org.jruby.javasupport.bsf.JRubyEngine\", \n                                   new String[] { \"rb\" });\n\nBSFManager manager = new BSFManager();\n\n/* Import an object using declareBean then you can access it in JRuby with $<name> */\n \nmanager.declareBean(\"label\", mylabel, JFrame.class);\nmanager.exec(\"ruby\", \"(java)\", 1, 1, \"$label.setText(\\\"This is a test.\\\")\");\n</pre>\n\n===Comparing the performance of JRuby script invocation in BSF with JSR223===\n\nInvoking JRuby scripts using JSR223 appear to be about 17  times faster than invoking them with BSF.\n\n{| class=\"wikitable\" style=\"text-align:left\" border=\"1\" cellpadding=\"5\" cellspacing=\"0\"\n|+'''JRuby Invocation Timings (500x)'''\n|-\n!  !! BSF !! JSR223 !!  rowspan=\"2\" | &nbsp;\n|-\n! Initial Invocation (ms) || 1465 || 155\n|-\n! Average (ms) || 110 || 6 || rowspan=\"2\" | these values do not  include the initial invocation time\n|-\n! Maximum (ms) || 826 || 96 \n|}\n\n''* The data were collected using Java 1.5.0_16 on a 2.5 GHz Core 2 Duo MacBook Pro.''\n\nThe following code samples and graphs show the timing results for creating 500 JRuby script engines and evaluating a short Ruby script.\n\n  file: TestJRubyBSF.java\n  \n  package org.concord.bsf.jruby;\n  import org.apache.bsf.BSFException;\n  import org.apache.bsf.BSFManager;\n  public class TestJRubyBSF {\n    public static void main(String[] args) throws BSFException {\n      BSFManager.registerScriptingEngine(\"ruby\",\n          \"org.jruby.javasupport.bsf.JRubyEngine\", new String[] { \"rb\" });\n      for (int i = 1; i <= 500; i++) {\n        try {\n          long start = System.currentTimeMillis();\n          BSFManager manager = new BSFManager();\n          manager.exec(\"ruby\", \"script\", 1, 1, \"Array.new(16) { rand(256) }.pack('C*').unpack('H*').first\");\n          System.out.println(i + \",\" + (System.currentTimeMillis() - start));\n        }\n        catch (Exception e) {\n          e.printStackTrace();\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n\n[[image:Jruby_bsf_invocation.png]]\n\n  file: TestJRubyJSR223.java\n\n  package org.concord.jsr223.jruby;\n  import com.sun.script.jruby.JRubyScriptEngineManager;\n  import javax.script.ScriptEngine;\n  public class TestJRubyJSR223 {\n    public static void main(String[] args) {\n      JRubyScriptEngineManager manager = new JRubyScriptEngineManager();\n      for (int i = 1; i <= 500; i++) {\n        try {     \n          long start = System.currentTimeMillis();\n          ScriptEngine engine = manager.getEngineByName(\"jruby\");\n          engine.eval(\"Array.new(16) { rand(256) }.pack('C*').unpack('H*').first\");\n          System.out.println(i + \",\" + (System.currentTimeMillis() - start));\n        }\n        catch (Exception e) {\n          e.printStackTrace();\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }\n\n[[Image:Jruby_jsr223_invocation.png]]\n\n===Directly calling JRuby APIs===\n\nSee [[Direct JRuby Embedding]]. The BSF and javax.scripting APIs are strongly recommended, as they are most likely to always do the \"right thing\", which may change over time in the direct version.\n\n==Gotchas==\nIf you plan on calling gems from an embedded script, there are a couple of things you need to be aware of: \n\nIf you ''require 'rubygems''', you need to make sure you set a few system properties: jruby.base, jruby.home, jruby.lib, jruby.shell, and jruby.script. You can look in bin/jruby (it's a shell script) or jruby.bat to examples of setting these from the command line. If, for some reason, you can't set them on the command line, you'll need to set them programmatically, or else you'll receive a NullPointerException when RbConfigLibrary loads.\n\nAlso, make sure you get the load path set properly. Running ''jirb'' and calling ''$LOAD_PATH.inspect'' should give you a good idea what paths need to be included. All of those paths can be set the same way you'd set a Java classpath. However, one reference to *lib/ruby/1.8* has to remain relative. This is because some files (*digest/sha2*, for example) are loaded from the jruby.jar. If you are running unit tests from Ant, you may have problems because Ant tends to expand pathelements. Fortunately, it's easy enough to append ''lib/ruby/1.8'' to the load path before calling ''require 'rubygems''' in your scripts.\n\nHere's an example load path from Linux:\n<pre>\nirb(main):004:0> puts $LOAD_PATH\n/home/username/jruby/lib/ruby/site_ruby/1.8\n/home/username/jruby/lib/ruby/site_ruby\n/home/username/jruby/lib/ruby/1.8\n/home/username/jruby/lib/ruby/1.8/java\nlib/ruby/1.8\n.\n=> nil\n</pre>\n\nHere's an example load path for Windows:\n* C:/common/jruby-0.9.2/lib/ruby/site_ruby/1.8\n* C:/common/jruby-0.9.2/lib/ruby/site_ruby/1.8/java\n* C:/common/jruby-0.9.2/lib/ruby/site_ruby\n* C:/common/jruby-0.9.2/lib/ruby/1.8\n* C:/common/jruby-0.9.2/lib/ruby/1.8/java\n* lib/ruby/1.8\n\nThese settings are specific to my system. Make sure the paths are correct for your system.\n\nIf you declare a bean using BSF, make sure you undeclare it when you are done using it ''even if you declare another bean using the same name''. BSF internally adds declared beans to a vector, and only removes them once they are undeclared.  Or, as an alternative, you can call registerBean and access the object from JRuby using the global $bsh reference.\n\n==See also==\n* [[Calling Java from JRuby]]\n* [[Accessing JRuby Object in Java]]\n\n==Related Articles==\n* [http://leandrosilva.com.br/2008/08/14/executar-jruby-a-partir-do-java Executar JRuby a partir do Java (pt_BR)] Article about integration of Java with JRuby, showing how running JRuby code from Java.\n","created_at":"2009-03-21T20:02:51Z","content_type":"application/vnd.com.kenai.page.revision+json"}