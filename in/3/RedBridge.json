{"href":"https://kenai.com/api/projects/jruby/features/wiki/pages/RedBridge/revisions/3.json","name":"RedBridge","number":3,"page_href":"https://kenai.com/api/projects/jruby/features/wiki/pages/RedBridge.json","person":"yokolet","description":"","text":"[[Home|&raquo; JRuby Project Wiki Home Page]]\n<h1>Embedding JRuby</h1>\nUsing Java from Ruby is a really nice feature that JRuby brings to you, but you can also use Ruby from Java. You can execute Ruby scripts in a Java program and invoke Ruby methods. You can even implement Java interface by Ruby and call implemented methods from Java.  We call it embedding, and this section explains how you can use it.\n\n__TOC__\n\n=Red Bridge (JRuby Embed) =\n\nJRuby\u2019s embedding has vastly changed since JRuby 1.4.0RC1, and, of course, it has been much improved. In that pivoted version, JRuby had Red Bridge (or JRuby Embed, new embedding API).  Red Bridge has its own Java API to run Ruby scripts as well as implementations of JSR223 and BSF on top of it. You don\u2019t need to download separate archive to use JSR223 anymore. Although JRuby still has a former implementation of BSF, Red Bridge\u2019s implementation fixed issues filed and became a better one for BSF users. We illustrates how you can code embedding by Red Bridge here, but you can reach to a [[JavaIntegration|previous embedding page]], too, if you want to keep a legacy embedding style.\n\n== Features of Red Bridge ==\nRed Bridge is consists of two layers, Embed Core on the bottom and JSR223/BSF implementations on the top. Embed Core is focused only on JRuby and designed to leverage JRuby\u2019s power as much as possible. This is a big difference from JSR223/BSF, which are intended to provide common interfaces to many scripting languages. When you use Embed Core, you don\u2019t need to rely on VM wide System property to configure. For example, you can set classpath Ruby version directly through the method of org.jruby.RubyInstanceConfig. You can read scripts using JRuby friendly java.io.InputStream, or get them from a classpath, too. Also Embed Core has various kinds of convenient, flexible methods. Those are shortcut methods or methods that return Java friendly objects. The methods defined in JRuby Embed will help you to avoid writing boilerplate code in your Java programs. We recommend Embed Core if you don\u2019t use other scripting language than Ruby. See  [http://jruby-embed.kenai.com/docs/ API document] for further detail.\n\n\nHowever, Red Bridge doesn\u2019t leave JSR223/BSF behind. Many of useful features are also available to use in those implementations. You can choose local context type, local variable behavior and compile mode, and set line numbers displayed in parsing error. Since Red Bridge is highly configurable, it will fit in various use cases. A downside of this might be that you need to walk through the document to find what you should do to get the best result.\n\n\nAmong configurations, choosing a right local context type is really important. If you make a wrong choice, you might be puzzled by unexpected results. If you want only one Ruby runtime, variable map or attribute map on JVM, choose singleton. If you run Ruby scripts on multi-threaded environment, you should choose threadsafe so that you don\u2019t worry about race condition to use Ruby runtime or other. Please be sure your choice is the best for your case.\n\n\nChoosing a local variable behavior would be interesting.  Sharing variables mechanism of Red Bridge is one of the most improved features compared with JSR223 reference implementation. By sharing variables mechanism of Red Bridge, local, instance, and global variables and constants are going back and forth between Java and Ruby. In case of Java to Ruby, variables are given through method arguments or directly injected to Ruby scripts. On the other hand, from Ruby, variables are implicitly handed over to Java. Ruby code doesn\u2019t need to do something special for sharing variables. When Ruby scripts return values, Java program can get them as normal Java objects. When Ruby scripts use variables, those names and values are available to take in to Java. What Java program should do is just getting a value with a variables name from a variable map. Local, instance, global variables and constants used in Ruby scripts are collected and hold in the variable map that Red Bridge takes care of. The variable map is also used to give values to Ruby from Java; thus, when you put key-value pair into the map, the pair is injected into Ruby code. Although sharing local and instance variables are limited in the current version, you don\u2019t need to heavily rely on global variables. Not like other scripting languages, when a variable name starts with \u201c$\u201d in Ruby, it becomes a global variable and is a globally shared on Ruby runtime. You can avoid relying on such globally shared variables to hand some states from Java to Ruby on Red Bridge. \n\n== Download ==\n\nJRuby Embed (Red Bridge) binary is included in JRuby 1.4.0RC1. Visit [http://www.jruby.org/download] to get the archive.The Archive of JRuby Embed version 1.2.0 is also available to download at: [http://kenai.com/projects/jruby-embed/downloads], too. JRuby Embed source codes are not included in JRuby 1.4.0x source archives. Get them at the Source Code Repository of this project, [http://kenai.com/projects/jruby-embed/sources]. However, JRuby 1.5.0 source archives will have JRuby Embed.\n\nAll users, please understand. Embed Core API may change in future releases.\n\nFor maven users:<br/>\nJRuby 1.4.0x archives in maven repo doesn't have JRuby Embed in it. It is on codehause maven repo, so add below to your pom.xml:\n<pre name=\"xml\">\n.....\n    <repository>\n      <id>codehaus</id>\n      <name>Maven Codehaus repository</name>\n      <url>http://repository.codehaus.org/</url>\n    </repository>\n....\n....\n   <dependency>\n      <groupId>org.jruby.embed</groupId>\n      <artifactId>jruby-embed</artifactId>\n      <version>0.1.2</version>\n    </dependency>\n....\n</pre>\n\nAlso, JRuby 1.5.0 will have JRuby Embed in it, so you don't need to add jruby-embed dependency.\n\n== Getting Started ==\n\nTo get to know how to develop it, a simple 'Hello World' sample is always the first friend. Here are samples to say 'Hello World' in a JRuby Embed way. \n\nBefore you start programming, make sure necessary jar archives are in your classpath.\n;- Core\n:jruby-complete.jar (or jruby.jar)\n;- JSR223\n:jruby-complete.jar (or jruby.jar), script-api.jar(if you are using JDK1.5)\n;- BSF\n:jruby-complete.jar (or jruby.jar), bsf.jar, commons-logging-[version].jar\n\n\nPrograms to execute a simple Ruby script, puts \"Hello World!,\" using JRuby Embed are:\n* Core\n<pre name=\"java\">\npackage vanilla;\n\nimport org.jruby.embed.ScriptingContainer;\n\npublic class HelloWorld {\n\n    private HelloWorld() {\n        ScriptingContainer container = new ScriptingContainer();\n        container.runScriptlet(\"puts \\\"Hello World!\\\"\");\n    }\n\n    public static void main(String[] args) {\n        new HelloWorld();\n    }\n}</pre>\n\n* JSR223\n<pre name=\"java\">\npackage redbridge;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\npublic class Jsr223HelloWorld {\n\n    private Jsr223HelloWorld() throws ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"jruby\");\n        engine.eval(\"puts \\\"Hello World!\\\"\");\n    }\n\n    public static void main(String[] args) throws ScriptException {\n        new Jsr223HelloWorld();\n    }\n}</pre>\n\n* BSF\n<pre name=\"java\">\npackage azuki;\n\nimport org.apache.bsf.BSFException;\nimport org.apache.bsf.BSFManager;\n\npublic class BsfHelloWorld {\n    private BsfHelloWorld() throws BSFException {\n        BSFManager.registerScriptingEngine(\"jruby\", \"org.jruby.embed.bsf.JRubyEngine\", new String[] {\"rb\"});\n        BSFManager manager = new BSFManager();\n        manager.exec(\"jruby\", \"<script>\", 0, 0, \"puts \\\"Hello World!\\\"\");\n    }\n\n    public static void main(String[] args) throws BSFException {\n        new BsfHelloWorld();\n    }\n\n}</pre>\n\nAll three programs print out \"Hello World!\" to standard output.\n\n== Configurations ==\n\nAlthough default setting works well, JRuby Embed allows you to configure its environment and behavior. In this section, you can find what configuration options are and how to configure them. In case of Embed core, most options are set through arguments of constructors or methods easily. Meanwhile, JSR223/BSF are often not flexible to accept JRuby specific parameters. Therefore, System properties and JSR223\u2019s attributes are used for this purpose.\n\nPlease remember you need to set parameters before instantiating a container/engine when you want to make per container configurations work.\n\n;The per container configurations are:\n:JRuby Home\n:Class Path\n:Context Instance Type\n:Local Variable Behavior\n:Compile Mode\n:Ruby Version\n\nIf you want set per evaluation configurations, set them just before the evaluation or the method arguments.\n\n; The per evaluations configuration is:\n:Line Number\n\n=== JRuby Home ===\n\nScope: Per Container<br/>\nPropety Name: jruby.home\n\n\n\nJRuby Home is a home directory (or folder) of JRuby and is used to load JRuby\u2019s built-in libraries and for other purposes by JRuby. Internally, JRuby Embed tries to get a directory from the order of JRUBY_HOME environment variable, , jruby.home system property, then jruby.home assembled in jruby-complete.jar. If you are using jruby-complete.jar, you are free from worrying about this configuration. If you aren\u2019t using jruby-complete.jar, it is better to set it to avoid unexpected troubles although setting JRuby Home is optional in the domain of JRuby Embed.\n\nWhen you write a web application, you should use jruby-complete.jar because setting an absolute path to JRuby does not make sense. You should keep a war archive portable.\n\nJRUBY_HOME environment variable setting depends on OS. For example, on bash of Unix and OS X:\n<pre>\nexport JRUBY_HOME=/Users/yoko/Tools/jruby-1.3.1</pre>\n\nWhen you want to use jruby.home system property, you have two ways of setting the value: a command line option or java.langSystem#setProperty().\n\n* Core, JSR223, BSF\n<pre>\njava \u2013J-Djruby.home=/Users/yoko/Tools/jruby-1.3.1 \u2013cp \u2026</pre>\n<pre name=\"java\">\nSystem.setProperty(\"jruby.home\", \"/Users/yoko/Tools/jruby-1.3.1\");\nScriptingContainer container = new ScriptingContainer();</pre>\n\nIf you use Embed Core, then you can directly set jruby.home using the method:\n\n* Core\n<pre name=\"java\">\nScriptingContainer container = new ScriptingContainer();\ncontainer.getProvider().getRubyInstanceConfig().setJRubyHome(\"/Users/yoko/Tools/jruby-1.3.1\");</pre>\n\n\n=== Class Path ===\n\nScope: Per Container<br/>\nPropety Name: org.jruby.embed.class.path (or java.class.path)\n\n\n\nClasspaths are used to load Ruby scripts as well as Java classes and jar archives. Embed Core and BSF have a method to set classpath. However, JSR223 doesn't have such method or method argument. Thus, JSR223 need to be set classpath by system property. Either org.jruby.embed.class.path or java.class.path property names can be used to set classpath. The org.jruby.embed.class.path system property is avaiable to use in Embed Core and BSF, too. In case of Embed Core and JSR223, a value assigned to org.jruby.embed.class.path is looked up first, then java.class.path. This means that only org.jruby.embed.class.path is used if exists.  As for BSF, after java.class.path is looked up, org.jruby.embed.class.path  is added to if exists. The format of the paths is the same as Java's class path syntax, :(colon) separated path string on Unix and OS X or ;(semi-colon) separated one on Windows. Be sure to set classpaths before you instantiate javax.script.ScriptEngineManager or register engine to org.apache.bsf.BSFManager.\nSamples below run testMath.rb, which is included in JRuby\u2019s source archive. The script, testMath.rb, needs minirunit.rb, which should be loaded from the classpath.\n\n* Core\n<pre name=\"java\">\npackage vanilla;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jruby.embed.PathType;\nimport org.jruby.embed.ScriptingContainer;\n\npublic class LoadPathSample {\n    private final static String jrubyhome = \"/Users/yoko/Tools/jruby-1.3.1\";\n    private final String filename = jrubyhome + \"/test/testMath.rb\";\n\n    private LoadPathSample() {\n        ScriptingContainer container = new ScriptingContainer();\n        List<String> loadPaths = new ArrayList();\n        loadPaths.add(jrubyhome);\n        container.getProvider().setLoadPaths(loadPaths);\n        container.runScriptlet(PathType.ABSOLUTE, filename);\n    }\n\n    public static void main(String[] args) {\n        new LoadPathSample();\n    }\n}</pre>\n\n\n* JSR223\n<pre name=\"java\">\npackage redbridge;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.Reader;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\npublic class Jsr223LoadPathSample {\n    private final static String jrubyhome = \"/Users/yoko/Tools/jruby-1.3.1\";\n    private final String filename = jrubyhome + \"/test/testMath.rb\";\n\n    private Jsr223LoadPathSample() throws ScriptException, FileNotFoundException {\n        System.setProperty(\"org.jruby.embed.class.path\", jrubyhome);\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"jruby\");\n        Reader reader = new FileReader(filename);\n        engine.eval(reader);\n    }\n\n    public static void main(String[] args) throws ScriptException, FileNotFoundException {\n        new Jsr223LoadPathSample();\n    }\n} </pre>\n\n\n* BSF\n<pre name=\"java\">\npackage azuki;\n\nimport java.io.FileNotFoundException;\nimport org.apache.bsf.BSFException;\nimport org.apache.bsf.BSFManager;\nimport org.jruby.embed.PathType;\n\npublic class BsfLoadPathSample {\n    private final static String jrubyhome = \"/Users/yoko/Tools/jruby-1.3.1\";\n    private final String filename = jrubyhome + \"/test/testMath.rb\";\n    \n    private BsfLoadPathSample() throws BSFException, FileNotFoundException {\n        BSFManager.registerScriptingEngine(\"jruby\", \"org.jruby.embed.bsf.JRubyEngine\", new String[] {\"rb\"});\n        BSFManager manager = new BSFManager();\n        manager.setClassPath(jrubyhome);\n        manager.exec(\"jruby\", filename, 0, 0, PathType.ABSOLUTE);\n    }\n\n    public static void main(String[] args) throws BSFException, FileNotFoundException {\n        new BsfLoadPathSample();\n    }\n}</pre>\n\n\n\n=== Context Instance Type ===\n\nScope: Per Container<br/>\nProperty Name: org.jruby.embed.localcontext.scope<br/>\nValue: singleton(default in JRuby trunk; rev. 9e557a2 and later), theadsafe (default in version 0.1.2) or singlethread\n\nThe context instance type is a type of a local context. The local context holds Ruby runtime, name-value pairs for sharing variables between Java and Ruby, default I/O streams (reader/writer/error writer), and attributes. The context is saved in one of three types, threadsafe, singlethread, or singleton. Three types are defined in org.jruby.embed.LocalContextScope and also can be set by a system property. \n\nMake sure to set the context type before you instantiate javax.script.ScriptEngineManager or register engine to org.apache.bsf.BSFManager.\n\n==== Singleton ====\nThis model uses a well known Singleton pattern, and the only one instance of a local context will exist on JVM.<br/>\n\n* Core\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalContextScope.SINGLETON);\n</pre>\n\n* JSR223/BSF\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.localcontext.scope\", \"singleton\");\n</pre>\n\n\n\n==== ThreadSafe ====\nScript's parsings and evaluations should be safely performed on a multi-threaded environment such as servlet container. A supposed usage is that ScriptEngine is instantiateted in servlet's init() method and evaluates scripts in servlet's service() method.<br/>\n\n* Core\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalContextScope.THREADSAFE);\n</pre>\n\n* JSR223/BSF\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.localcontext.scope\", \"threadsafe\");\n</pre>\n\n==== SingleThread ====\nThis model pretends as if there is only one thread in the world, and does not mind race condition at all. Users are resposnsible to thread safety. If you want to instantiate ScriptEngine in servlet's service() method, this model would be the best suited one.\n\n* Core\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalContextScope.SINGLETHREAD);\n</pre>\n\n* JSR223/BSF\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.localcontext.scope\", \"threadsafe\");\n</pre>\n\n\n\n=== Local Variable Behavior Options ===\n\nScope: Per Container<br/>\nProperty Name: org.jruby.embed.localvariable.behavior<br/>\nValue: transient (default for core), persistent, global (default for JSR223), or bsf (for BSF)\n\nJRuby Embed enables to share Ruby's local, instance, global variables, and constants. To share these variables between Ruby and Java, JRuby Embed offers four types of local variable behaviors, transient, persistent, global, and bsf. Four types are defined in org.jruby.embed.LocalVariableBehavior and also can be set by a system property.\n\n\n==== Transient Local Variable Behavior ====\n\nDefault for Embed Core. Local variables' scope is faithful to Ruby semantics. This means local variable does not survive over the multiple evaluations. After the each evaluation, local variable will vanish away. However, instance and global variables, and constants survive unless those are removed explicitly. If you use global variables, the variables can be referred literally globally in Ruby runtime and exist as long as the runtime is alive. Be careful to the scope of global variables so that you don\u2019t mix in vulnerabilities in a web application.<br/>\n\n* Core\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer();\n</pre>\nor\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalVariableBehavior.TRANSIENT);\n</pre>\nor\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalContextScope.SINGLETHREAD, LocalVariableBehavior.TRANSIENT);\n</pre>\n\n* JSR223\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.localvariable.behavior\", \"transient\");\nScriptEngineManager manager = new ScriptEngineManager();\nScriptEngine engine = manager.getEngineByName(\"jruby\");\n</pre>\n\n* BSF\nBSF can choose only BSF type.\n\n==== Persistent Local Variable Behavior ====\n\nWhen this type is chosen, JRuby Embed keeps sharing all local variables' over multiple evaluations. This might not be a semantically correct usage, but is useful in some cases especially for users who have BSF background.<br/>\n\n* Core\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalVariableBehavior.PERSISTENT);\n</pre>\nor\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalContextScope.SINGLETHREAD, LocalVariableBehavior.PERSISTENT);\n</pre>\n\n* JSR223\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.localvariable.behavior\", \"persistent\");\nScriptEngineManager manager = new ScriptEngineManager();\nScriptEngine engine = manager.getEngineByName(\"jruby\");\n</pre>\n\n* BSF\nBSF can choose only BSF type.\n\n==== Global Local Variable Behavior ====\n\nDefault for JSR223. This behavior might be convenient to users who have used JSR 223 reference implementation released at scripging.dev.java.net and don't want change any code at all. With names like Ruby's local variable name, variables are mapped to Ruby's global variables. Only global variables can be shared between Ruby and Java, when this behavior is chosen. The values of global variables of this type are not kept over the evaluations. <br/>\n\n* Core\n<pre name=\"java\">\nScriptingContainer instance = new ScriptingContainer(LocalVariableBehavior.GLOBAL);\n</pre>\n\n\n* JSR223\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.localvariable.behavior\", \"global\");\nScriptEngineManager manager = new ScriptEngineManager();\nScriptEngine engine = manager.getEngineByName(\"jruby\");\n</pre>\n\n* BSF\nBSF can choose only BSF type.\n\n==== BSF Local Variable Behavior ====\n\nDefault for BSF. Local and global variables are available to share between Java and Ruby. Variable names doesn\u2019t start with \u201c$\u201d no matter what the variable types are. Since BSF has a method defined for sharing local variables, it doesn\u2019t confuse. However, core and JSR223 will confuse variables, so don\u2019t use this type for them.<br/>\n\n\n* Core/JSR223\nDon\u2019t choose this behavior.\n\n*BSF\n<pre name=\"java\">\nBSFManager.registerScriptingEngine(\"jruby\", \"org.jruby.embed.bsf.JRubyEngine\", new String[] {\"rb\"});\nBSFManager manager = new BSFManager();\n</pre>\nor\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.localvariable.behavior\", \"bsf\");\nBSFManager.registerScriptingEngine(\"jruby\", \"org.jruby.embed.bsf.JRubyEngine\", new String[] {\"rb\"});\nBSFManager manager = new BSFManager();\n</pre>\n\n\n=== CompileMode ===\n\nScope: Per Container<br/>\nProperty Name: org.jruby.embed.compilemode<br/>\nValue: off (default), jit, or force\n\nJRuby has jit and force options to compile Ruby scripts. This configuration provides users a way of setting a compile mode. When jit or force is specified, only a global variable can be shared between Ruby and Java.\n\nThis option is not for pre-compiled Ruby scripts. Ruby2java [http://kenai.com/projects/ruby2java] generated Java classes are not executable on current JRuby Embed.\n\n* Core\n<pre name=\"java\">\nScriptingContainer container = new ScriptingContainer();\ncontainer.getProvider().getRubyInstanceConfig().setCompileMode(CompileMode.JIT);\n</pre>\n\n\n*JSR223/BSF\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.compilemode\", \"jit\");\n</pre>\n\n\n=== Ruby Version ===\n\nScope: Per Container<br/>\nProperty Name: org.jruby.embed.compat.version<br/>\nValue: jruby19, JRuby1_9, ruby1.9\u2026.matches [jJ]?(r|R)(u|U)(b|B)(y|Y)1[\\\\._]?9\n\nDefault Ruby version is 1.8. When you want to use Ruby 1.9 on JRuby Embed, you need to specify the version. In case of Embed Core, the method to set the version is available to use. JSR223 needs system property to recognize the version. BSF judges the registered name. If the system property name or registered name matches the regular expression, [jJ]?(r|R)(u|U)(b|B)(y|Y)1[\\\\._]?9, Ruby 1.9 is chosen to run scripts. If no system property is there, or matching fails, Ruby 1.8 is chosen.\n\n* Core\n<pre name=\"java\">\nScriptingContainer container = new ScriptingContainer();    container.getProvider().getRubyInstanceConfig().setCompatVersion(CompatVersion.RUBY1_9);\n</pre>\n\n* JSR223\n<pre name=\"java\">\nSystem.setProperty(\"org.jruby.embed.compat.version\", \"JRuby1.9\");\nJRubyScriptEngineManager manager = new JRubyScriptEngineManager();\nJRubyEngine engine = (JRubyEngine) manager.getEngineByName(\"jruby\");\n</pre>\n\n*BSF\n<pre name=\"java\">\nBSFManager.registerScriptingEngine(\"jruby19\", \"org.jruby.embed.bsf.JRubyEngine\", new String[] {\"rb\"});\nBSFManager manager = new BSFManager();\nmanager.exec(\"jruby19\", \"ruby/block-param-scope.rb\", 0, 0, PathType.CLASSPATH);\n</pre>\n\n\n=== Line Number ===\n\nScope: Per Evaluation<br/>\nAttribute Name: org.jruby.embed.linenumber<br/>\nValue: 1, 2, 3,,,, (integer)\n\nEmbed Core and BSF have a method argument to set a line number to display for parse errors and backtracks, but JSR223 doesn\u2019t. When you want to specify a line number on JSR223, use the attribute.\n\n\n* Core\n<pre name=\"java\">\nprivate final String script =\n            \"puts \\\"Hello World.\\\"\\n\" +\n            \"puts \\\"Error is here.\";\nScriptingContainer container = new ScriptingContainer();\nEvalUnit unit = container.parse(script, 1);\nObject ret = unit.run();</pre>\n\n* JSR223\n<pre name=\"java\">\nimport javax.script.ScriptContext;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptException;\nimport org.jruby.embed.jsr223.JRubyScriptEngineManager;\n\npublic class LineNumberSample {\n    private final String script =\n            \"puts \\\"Hello World.\\\"\\n\" +\n            \"puts \\\"Error is here.\";\n\n    private LineNumberSample() throws ScriptException {\n        JRubyScriptEngineManager manager = new JRubyScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"jruby\");\n        try {\n            engine.eval(script);    // Since no line number is given, 0 is applied to.\n        } catch (Exception e) {\n            ;\n        }\n        try {\n            engine.getContext().setAttribute(\"org.jruby.embed.linenumber\", 1, ScriptContext.ENGINE_SCOPE);\n            engine.eval(script);\n        } catch (Exception e) {\n            ;\n        }\n        try {\n            engine.getContext().setAttribute(\"org.jruby.embed.linenumber\", 2, ScriptContext.ENGINE_SCOPE);\n            engine.eval(script);\n        } catch (Exception e) {\n            ;\n        }\n    }\n\n    public static void main(String[] args)\n            throws ScriptException {\n        new LineNumberSample();\n    }\n}</pre>\n\nOutputs:<pre>\n:1: <script>:2: unterminated string meets end of file (SyntaxError)\n:1: <script>:3: unterminated string meets end of file (SyntaxError)\n:1: <script>:4: unterminated string meets end of file (SyntaxError)\n</pre>\n\n* BSF\n<pre name=\"java\">\nprivate final String script =\n            \"puts \\\"Hello World.\\\"\\n\" +\n            \"puts \\\"Error is here.\";\nBSFManager.registerScriptingEngine(\"jruby\", \"org.jruby.embed.bsf.JRubyEngine\", new String[] {\"rb\"});\nBSFManager manager = new BSFManager();\nmanager.exec(\"jruby\", \u201c<script>\u201d, 1, 0, script);</pre>\n\n\n=== Other Ruby Runtime Configurations ===\n\nWhen you want to configure Ruby runtime more than explained here, you can use methods of org.jruby.RubyInstanceConfig on Embed Core. Get the reference of RubyInstanceConfig by ScriptingContainer.getProvider().getRubyInstanceConfig() and set values in it before you set/get key-value pairs, get runtime, or parse/eval/runScriptlet. However, JSR223/BSF can't do more configurations. If you want some configurations to work, file it in the issue tracker.\n\n\n== Red Bridge Code Examples ==\nSee [[RedBridgeExamples]] page.\n\n\n== Red Bridge Servlet Examples ==\nSee [[RedBrigeServletExamples]] page.\n\n= Previous Embedding JRuby Page=\n[[JavaIntegration|Embedding JRuby]]\n","created_at":"2009-11-01T22:15:51Z","content_type":"application/vnd.com.kenai.page.revision+json"}